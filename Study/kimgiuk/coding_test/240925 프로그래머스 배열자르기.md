### 문제 설명
https://school.programmers.co.kr/learn/courses/30/lessons/87390

정수 `n`, `left`, `right`가 주어질 때, n행 n열 크기의 배열을 만들고 다음 과정을 통해 1차원 배열을 생성하는 문제입니다.

1. **2차원 배열 생성**:
    - n x n 크기의 비어있는 2차원 배열을 만듭니다.

2. **배열 채우기**:
    - 각 행 `i`에 대해서, 1행 1열부터 i행 i열까지의 영역을 숫자 `i`로 채웁니다.
    - 즉, 배열에서 각 원소 arr[i][j]는 `max(i, j) + 1`입니다.

3. **1차원 배열 만들기**:
    - 완성된 2차원 배열을 행 단위로 잘라내어 모두 이어붙인 1차원 배열 `arr`을 만듭니다.

4. **부분 배열 추출**:
    - 1차원 배열 `arr`에서 `arr[left]`부터 `arr[right]`까지의 부분 배열을 추출하고, 나머지 부분은 제거합니다.

### 문제 요구 사항

주어진 `n`, `left`, `right`를 이용해 배열을 만들고, 특정 범위의 부분 배열을 반환하는 함수를 구현해야 합니다.

### 제한사항

- `1 ≤ n ≤ 10^7`
- `0 ≤ left ≤ right < n^2`
- `right - left < 10^5`

### 입출력 예시
![](https://i.postimg.cc/SxrF7K5z/Flattened-Fills-ex1.gif)

![](https://i.postimg.cc/sXMkr42p/Flattened-Fills-ex2.gif)

| n  | left | right | result              |
|----|------|-------|---------------------|
| 3  | 2    | 5     | [3, 2, 2, 3]        |
| 4  | 7    | 14    | [4, 3, 3, 3, 4, 4, 4, 4] |

### 해결 방법

문제를 해결하기 위해 실제로 n x n 크기의 2차원 배열을 만들지 않고, 인덱스만을 사용하여 배열의 값을 구하는 방식으로 접근해야 합니다. 이는 메모리와 성능을 최적화하기 위해서 필요한 방식입니다.

**핵심 아이디어**:
- `n^2` 크기의 2차원 배열을 1차원 배열로 변환하는 과정을 시뮬레이션하는 것입니다.
- 이때, 1차원 배열에서의 인덱스 `k`는 2차원 배열에서 `i = k / n`, `j = k % n`으로 변환됩니다.
- `arr[i][j]`의 값은 `max(i, j) + 1`입니다. 이 규칙을 이용하여 `left`부터 `right`까지 필요한 값만 구합니다.

### 코드 구현

```java
class Solution {
    public int[] solution(int n, long left, long right) {
        int size = (int)(right - left + 1);  // 구할 배열의 크기
        int[] answer = new int[size];  // 결과 배열
        
        int idx = 0;
        for (long k = left; k <= right; k++) {
            int i = (int)(k / n);  // 행
            int j = (int)(k % n);  // 열
            answer[idx++] = Math.max(i, j) + 1;
        }
        
        return answer;
    }
}
```

### 코드 설명

1. **변수 선언**:
    - `size`: `right - left + 1`로 구할 배열의 크기를 계산하여 필요한 메모리를 효율적으로 사용합니다.
    - `answer`: 결과를 저장할 배열입니다.

2. **1차원 배열을 시뮬레이션**:
    - 주어진 `left`부터 `right`까지의 범위 내에서 각 인덱스 `k`에 대해, `k`를 2차원 배열의 `(i, j)` 좌표로 변환합니다.
    - `i`는 `k / n`, `j`는 `k % n`으로 계산됩니다.
    - 2차원 배열에서의 값은 `max(i, j) + 1`이므로, 이를 기반으로 값을 계산하고 배열에 저장합니다.

3. **결과 반환**:
    - 계산된 배열 `answer`를 반환합니다.

### 시간 복잡도

- 배열의 크기는 최대 `right - left + 1`로 제한되어 있으며, `right - left < 10^5`이므로 시간 복잡도는 O(right - left)입니다.
- 따라서 주어진 문제의 제한 사항을 만족하며, 성능 상 문제없이 동작합니다.

### 메모리 최적화

문제를 해결하기 위해 2차원 배열을 직접 생성하지 않고, 필요한 범위에 대해서만 값을 계산하여 메모리 사용을 최소화하였습니다. 이를 통해 `n`이 큰 경우에도 효율적으로 동작할 수 있습니다.