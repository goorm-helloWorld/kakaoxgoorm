### 문제 설명

https://school.programmers.co.kr/learn/courses/30/lessons/12910

주어진 배열 `arr`의 각 요소 중에서, `divisor`로 나누어 떨어지는 값만을 추출하여 오름차순으로 정렬된 배열을 반환하는 함수를 작성하는 문제입니다. 만약 배열 내에 `divisor`로 나누어 떨어지는 값이 하나도 없다면, `-1`을 담은 배열을 반환해야 합니다.

### 제한사항
- 배열 `arr`는 자연수를 담고 있으며, 각 원소는 서로 다른 값을 갖습니다.
- `divisor`는 자연수입니다.
- 배열 `arr`의 길이는 1 이상입니다.

### 입출력 예시

| arr           | divisor | return            |
|---------------|---------|-------------------|
| [5, 9, 7, 10] | 5       | [5, 10]           |
| [2, 36, 1, 3] | 1       | [1, 2, 3, 36]     |
| [3, 2, 6]     | 10      | [-1]              |

#### 입출력 예 #1
- 배열 `[5, 9, 7, 10]` 중에서 5로 나누어 떨어지는 값은 5와 10입니다.
- 이 값들을 오름차순으로 정렬하면 `[5, 10]`이 됩니다.

#### 입출력 예 #2
- 배열 `[2, 36, 1, 3]`에서 모든 요소는 1로 나누어 떨어집니다.
- 이 값들을 오름차순으로 정렬하면 `[1, 2, 3, 36]`이 됩니다.

#### 입출력 예 #3
- 배열 `[3, 2, 6]`의 원소들은 10으로 나누어 떨어지지 않습니다.
- 따라서 `[-1]`을 반환합니다.

### 알고리즘 설명

1. **배열 순회 및 필터링**:
    - 배열 `arr`의 각 요소에 대해 `divisor`로 나누어 떨어지는지 확인합니다. 이때, 나누어 떨어지는 값들만 추출합니다.

2. **정렬 및 변환**:
    - 추출된 값들을 오름차순으로 정렬합니다.
    - 추출된 값이 없다면, `-1`이 담긴 배열을 반환합니다. 그렇지 않으면, 정렬된 배열을 반환합니다.

### 코드 구현

```java
import java.util.*;

class Solution {
    public int[] solution(int[] arr, int divisor) {
        // 배열을 순회하며 divisor로 나누어 떨어지는 값들을 Stream으로 필터링하고, 정렬 후 배열로 변환
        int[] answer = Arrays.stream(arr)
                             .filter(i -> i % divisor == 0)  // 나누어 떨어지는 값 필터링
                             .sorted()                       // 정렬
                             .toArray();                     // 배열로 변환
        
        // 나누어 떨어지는 값이 없는 경우 -1 반환
        if (answer.length == 0) {
            return new int[]{-1};
        } else {
            return answer;
        }
    }
}
```

### 코드 설명

1. **Stream API 사용**:
    - `Arrays.stream(arr)`: `arr` 배열을 Stream으로 변환합니다.
    - `filter(i -> i % divisor == 0)`: 각 요소가 `divisor`로 나누어 떨어지는지 확인하여, 해당 조건을 만족하는 값들만 필터링합니다.
    - `sorted()`: 필터링된 값을 오름차순으로 정렬합니다.
    - `toArray()`: 정렬된 Stream을 배열로 변환합니다.

2. **조건 처리**:
    - 필터링된 배열이 비어 있을 경우, `-1`이 담긴 배열을 반환합니다.
    - 그렇지 않으면, 정렬된 배열을 반환합니다.

### 시간 복잡도

- **필터링**: 배열의 모든 요소에 대해 나누어 떨어지는지 확인하는 작업은 O(n)의 시간이 걸립니다.
- **정렬**: 정렬은 O(m log m)의 시간이 걸립니다. 여기서 m은 나누어 떨어지는 값의 개수입니다.
- 따라서 전체 시간 복잡도는 O(n + m log m)이며, 이는 일반적으로 효율적입니다.