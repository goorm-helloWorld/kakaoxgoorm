### 문제 설명
https://school.programmers.co.kr/learn/courses/30/lessons/49994?language=java

게임 캐릭터가 4가지 명령어(`U`, `D`, `R`, `L`)에 따라 좌표 평면에서 이동을 시작합니다. 캐릭터는 (0, 0)에서 시작하며, 좌표 평면의 경계는 아래와 같습니다:

![](https://i.postimg.cc/tTs5TrW4/1-qpp9l3.png)

- 왼쪽 위: (-5, 5)
- 오른쪽 위: (5, 5)
- 왼쪽 아래: (-5, -5)
- 오른쪽 아래: (5, -5)

캐릭터는 주어진 명령어에 따라 좌표를 이동합니다. 예를 들어, 명령어가 "ULURRDLLU"일 때 캐릭터는 9번 이동을 하지만, 이미 지나간 길을 다시 이동한 경우는 길이로 계산되지 않습니다. 처음 이동한 경로만 길이로 계산되며, 경계를 벗어나는 명령어는 무시됩니다.

![](https://i.postimg.cc/ZRXLyrxF/2-lezmdo.png)

![](https://i.postimg.cc/hG5LH96W/3-sootjd.png)

![](https://i.postimg.cc/gkHvY9QK/4-hlpiej.png)

만약 명령어가 "LULLLLLLU"로 입력되었다면, 

![](https://i.postimg.cc/13zNs8p9/5-nitjwj.png)

1번 명령어부터 6번 명령어대로 움직인 후, 7, 8번 명령어는 무시합니다. 다시 9번 명령어대로 움직입니다.

![](https://i.postimg.cc/QxfH4jvv/6-nzhumd.png)

### 문제 요구 사항

주어진 명령어를 통해 캐릭터가 처음으로 이동한 길의 총 길이를 구하는 프로그램을 작성하세요. 길이는 캐릭터가 처음 걸어본 경로만 계산하며, 중복된 경로나 좌표 평면을 벗어난 이동은 무시됩니다.

### 제한사항
- `dirs`는 'U', 'D', 'R', 'L'로 이루어진 문자열입니다.
- `dirs`의 길이는 최대 500자 이하입니다.
- 경계를 벗어난 명령어는 무시됩니다.

### 입출력 예시

- **입력**: "ULURRDLLU" → **출력**: 7
- **입력**: "LULLLLLLU" → **출력**: 7

### 알고리즘 설명

1. **초기 설정**:
    - 캐릭터는 (0, 0)에서 시작합니다.
    - 좌표가 넘어가는 범위는 (-5, 5)입니다. 좌표의 이동이 이 범위를 넘어가면 무시됩니다.
    - 지나간 경로를 기록하기 위해 `Set` 자료구조를 사용합니다. `Set`은 중복된 값을 저장하지 않으므로, 지나간 길을 중복 없이 기록할 수 있습니다.
    - 이동 방향은 상(`U`), 하(`D`), 좌(`L`), 우(`R`)로 이루어져 있습니다. 이동을 위한 배열을 미리 설정합니다.

2. **이동 처리**:
    - 주어진 명령어를 하나씩 확인하면서 현재 위치에서 다음 위치로 이동을 시도합니다.
    - 이동할 때, 새 좌표가 좌표평면의 경계를 벗어나지 않는지 확인하고, 경계를 넘어가는 경우는 무시합니다.
    - 만약 새 좌표로 이동이 가능하다면, 캐릭터가 지나간 경로를 `Set`에 저장합니다. 이때, (출발지 → 도착지)와 (도착지 → 출발지)를 모두 저장해 양방향을 기록합니다.
    - 중복되지 않은 길은 처음 이동한 길로 간주되므로 길이 계산 시에 반영됩니다.

3. **결과 계산**:
    - `Set`에 저장된 경로는 양방향으로 기록되었기 때문에 실제 경로의 길이는 `Set`의 크기의 절반이 됩니다.

### 코드 구현

```java
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int solution(String dirs) {
        // 현재 위치를 (0,0)으로 설정
        int x = 0;
        int y = 0;
        
        // 지나간 길을 저장하기 위한 Set
        Set<String> visited = new HashSet<>();
        
        // 이동 명령어에 따른 방향 변화 (상, 하, 좌, 우)
        int[] dx = {0, 0, -1, 1};  // 좌우
        int[] dy = {1, -1, 0, 0};  // 상하
        String direction = "UDLR"; // 명령어의 순서와 매칭
        
        for (char dir : dirs.toCharArray()) {
            // 현재 명령어의 방향 인덱스를 얻음
            int idx = direction.indexOf(dir);
            
            // 새로운 좌표 계산
            int nx = x + dx[idx];
            int ny = y + dy[idx];
            
            // 좌표가 경계를 넘어서면 무시
            if (nx < -5 || nx > 5 || ny < -5 || ny > 5) {
                continue;
            }
            
            // 지나간 경로 저장 (현재 좌표 -> 다음 좌표, 양방향 저장)
            String path1 = x + "," + y + "->" + nx + "," + ny;
            String path2 = nx + "," + ny + "->" + x + "," + y;
            
            // 처음 지나간 길이면 Set에 추가하고, 길이를 증가시킴
            if (!visited.contains(path1)) {
                visited.add(path1);
                visited.add(path2); // 양방향 저장
            }
            
            // 현재 좌표를 업데이트
            x = nx;
            y = ny;
        }
        
        // 총 길이는 방문한 경로 수의 절반 (양방향 저장했기 때문에)
        return visited.size() / 2;
    }
}
```

### 코드 설명

1. **변수 설정**:
    - `x`, `y`: 현재 캐릭터의 위치를 저장하는 변수입니다.
    - `visited`: 캐릭터가 지나간 경로를 기록하는 `Set`입니다.
    - `dx`, `dy`: 명령어에 따른 이동 방향을 설정한 배열입니다. 예를 들어, 'U'(Up)는 `dy` 배열에서 상향 이동을 의미합니다.

2. **명령어 처리**:
    - 명령어 문자열을 하나씩 처리하면서, `direction.indexOf(dir)`를 통해 이동 방향을 결정합니다.
    - 새로운 좌표를 계산한 후, 좌표가 경계를 넘지 않으면, 경로를 기록합니다. 이때, (출발지 -> 도착지)와 (도착지 -> 출발지)를 모두 기록합니다.

3. **결과 반환**:
    - 양방향 경로가 `Set`에 저장되어 있으므로, 길이는 `visited.size()`의 절반이 됩니다.

### 시간 복잡도

- 주어진 명령어의 길이가 최대 500자이므로, 시간 복잡도는 O(N)입니다. N은 명령어의 개수를 의미합니다.
- `Set`을 사용하여 지나간 경로를 저장하고 확인하므로, 각 명령어당 O(1)로 경로 기록이 가능합니다.