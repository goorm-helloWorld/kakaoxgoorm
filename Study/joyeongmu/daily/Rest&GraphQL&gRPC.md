

# REST, GraphQL, gRPC 비교

## 1. 개요

REST는 수년간 웹 API 설계의 사실상 표준으로 자리 잡았지만, GraphQL과 gRPC는 REST의 한계를 해결하기 위해 등장했습니다. 각 접근 방식에는 장단점이 있습니다.

## 2. REST

### 2.1 아키텍처 스타일

- **REST(Representational State Transfer)** 는 URL 구조와 HTTP 프로토콜을 기반으로 한 클라이언트-서버 상호 작용의 아키텍처 스타일입니다.
- 각 HTTP 메소드는 다음과 같은 작업을 수행합니다:
    - `GET`: 리소스 조회
    - `POST`: 새로운 리소스 생성
    - `PUT`: 리소스 업데이트 (없을 시 생성)
    - `DELETE`: 리소스 삭제
    - `PATCH`: 부분적인 리소스 업데이트

### 2.2 예제 서비스

```java
@GetMapping("/rest/books")
public List<Book> books() {
    return booksService.getBooks();
}

```

### 2.3 장단점

- **장점**: 성숙한 기술, 친숙함, 쉬운 모니터링 및 캐싱
- **단점**: 과도한 데이터 전송(Over-fetching), 중첩된 엔티티 데이터에 대한 여러 요청 필요

## 3. GraphQL

### 3.1 아키텍처 스타일

- **GraphQL**은 클라이언트 주도형 쿼리 언어로, 클라이언트가 필요한 데이터를 구체적으로 요청할 수 있습니다.
- 주로 `POST`를 사용하며, **Queries**, **Mutations**, **Subscriptions** 개념을 활용합니다.

### 3.2 예제 서비스

```java
@QueryMapping
public List<Book> books() {
    return booksService.getBooks();
}

```

- 요청시 body 예시 → Get을 이용하면 길이에 따른 제약이 생기기 때문에 post를 사용함

```
{
  "query": "{ books { title, author { firstName, lastName } } }"
}
```

### 3.3 장단점

- **장점**: 필요한 데이터만 전송 가능, 클라이언트 유연성
- **단점**: 캐싱 어려움, 복잡한 서버 쿼리로 인한 과부하 가능성

## 4. gRPC

### 4.1 아키텍처 스타일

- **gRPC**는 Google이 만든 고성능 RPC(Remote Procedure Call) 프레임워크로, 프로토콜 버퍼로 정의된 계약 기반 통신을 사용합니다.
- HTTP/2와 바이너리 포맷을 사용하여 높은 효율성을 보장합니다.

### 4.2 예제 서비스

```protobuf
service BooksService {
    rpc books(BooksRequest) returns (BooksResponse);
}

```

### 4.3 장단점

- **장점**: 높은 성능, 다중 언어 지원, 스트리밍 지원
- **단점**: 적은 인기, 브라우저 지원 부족, 디버깅 어려움

## 5. API 선택 기준

### 5.1 데이터 형식

- **REST**: JSON, XML 등 다양한 데이터 형식 지원
- **GraphQL**: JSON 응답, 변환 가능하지만 성능 저하 가능
- **gRPC**: 바이너리 프로토콜 버퍼 사용, 사람 읽기 불가

### 5.2 데이터 조회

- **GraphQL**은 클라이언트가 필요한 데이터만 요청할 수 있어 네트워크 전송 효율이 높습니다.

### 5.3 브라우저 지원

- **REST** 및 **GraphQL**은 모든 브라우저에서 지원됩니다.
- **gRPC**는 제한된 브라우저 지원을 제공하며, HTTP 1.1 확장을 사용합니다.

## 6. 혼합 사용

한 가지 접근 방식을 고수할 필요는 없습니다. 특정 계층에서 서로 다른 API 스타일을 혼합하여 사용할 수 있습니다.

---

## Rest vs GraphQL

음악 스트리밍 서비스에서 REST API를 이용한다면 해당 화면을 구성하기 위해 여러 개의 엔드포인트에 검색 요청을 해야할 것이다.

```
GET https://www.spotify.com/artist?query=아이들
GET https://www.spotify.com/music?query=아이들
GET https://www.spotify.com/album?query=아이들
```

하지만 GraphQL 에서는 한 번의 요청과 쿼리로 화면 구성에 필요한 모든 데이터를 가져올 수 있다.

**요청**

```
POST https://www.spotify.com/graphql
```

**쿼리**

```
{
	artist(query: "아이들") {
    	name
        ...
    }
    music(query: "아이들") {
		name
        ...
    }
    album(query: "아이들") {
    	name
        ...
    }
}
```

---

## API 접근 방식 고르기

---

### 1. **REST**:

**사용 상황**:

- **자원(Resource) 중심의 시스템**을 설계할 때 유리합니다. 각 자원이 고유한 URL로 식별되기 때문에, CRUD(생성, 조회, 수정, 삭제) 작업이 명확하게 매핑될 수 있습니다.
- **공개 API**나 **브라우저 지원**이 중요한 경우, REST는 널리 사용되며 표준화된 방식이기 때문에 익숙한 개발자들이 많습니다.
- **캐싱**이 중요한 경우, REST는 HTTP 표준 기반의 캐싱을 쉽게 지원하므로, 자주 변경되지 않는 데이터를 캐시하여 성능을 향상시킬 수 있습니다.

**적합한 경우**:

- 전 세계적으로 분산된 클라이언트가 있는 **대규모 공개 API**.
- **상대적으로 고정된 데이터**를 주고받는 API(예: 블로그 게시물, 뉴스 기사 등).

---

### 2. **GraphQL**:

**사용 상황**:

- **클라이언트가 다양한 데이터 요구**를 가지고 있고, 그에 따라 필요한 데이터를 유연하게 요청할 수 있을 때 유리합니다.
- *과도한 데이터 요청(Over-fetching)**이나 **부족한 데이터 요청(Under-fetching)** 문제가 있는 경우. GraphQL은 클라이언트가 필요한 데이터만 요청할 수 있어 효율적입니다.
- **다양한 데이터 소스에서 데이터를 집계**해야 하는 경우(예: 여러 API나 데이터베이스에서 데이터를 가져와 하나의 응답으로 제공).

**적합한 경우**:

- **동적이고 유연한 클라이언트 요구**를 만족시켜야 하는 복잡한 애플리케이션(예: 대시보드, 모바일 앱 등).
- **다중 API 집계가 필요한 상황**에서 데이터를 효과적으로 관리해야 할 때.

---

### 3. **gRPC**:

**사용 상황**:

- **고성능 및 낮은 대기 시간**이 중요한 경우. gRPC는 바이너리 포맷과 HTTP/2를 사용해 효율적으로 데이터를 전송하며, **대규모의 실시간 데이터 처리**가 필요한 경우에 적합합니다.
- **마이크로서비스 간의 통신**이 빈번하고, 서로 다른 언어로 작성된 서비스들 간의 통신을 원활히 해야 할 때 유리합니다.
- **스트리밍**을 통한 데이터 전송이 필요한 경우. gRPC는 **양방향 스트리밍**을 지원하여 실시간 데이터 전송에 유리합니다.

**적합한 경우**:

- **내부 서비스 간의 고성능 통신**이 필요한 **마이크로서비스 아키텍처**.
- **IoT** 같은 실시간 데이터 수집이 필요한 애플리케이션.
- **브라우저 지원이 필요 없는 내부 시스템**이나 네이티브 클라이언트를 사용하는 애플리케이션.

---

### 4. **혼합 사용**:

**사용 상황**:

- **다양한 계층**에서 각기 다른 API 접근 방식을 혼합하여 사용할 수 있습니다. 예를 들어, 외부 클라이언트에는 REST를 제공하면서, 내부 서비스 간 통신에는 gRPC를 사용할 수 있습니다.
- **GraphQL**과 **REST**를 함께 사용해, 일부 리소스는 REST로 제공하고, 복잡한 데이터 조회는 GraphQL로 처리할 수도 있습니다.

---

### **요약**:

- **REST**: 자원 중심의 CRUD, 캐싱이 중요한 경우, 브라우저 지원 필요 시.
- **GraphQL**: 유연한 데이터 요청, 클라이언트의 다양한 요구, 데이터 집계 필요 시.
- **gRPC**: 고성능, 스트리밍, 마이크로서비스 간 통신, 내부 시스템에 적합.