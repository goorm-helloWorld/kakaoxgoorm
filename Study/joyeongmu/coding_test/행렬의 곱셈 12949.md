## [level 2] 행렬의 곱셈 - 12949

https://school.programmers.co.kr/learn/courses/30/lessons/12949

## 문제 설명

2차원 행렬 `arr1`과 `arr2`를 입력받아, `arr1`에 `arr2`를 곱한 결과를 반환하는 함수 `solution`을 완성해주세요.

### 제한 조건

- 행렬 `arr1`, `arr2`의 행과 열의 길이는 2 이상 100 이하입니다.
- 행렬 `arr1`, `arr2`의 원소는 -10 이상 20 이하인 자연수입니다.
- 곱할 수 있는 배열만 주어집니다.

### 입출력 예

| arr1                            | arr2                            | return                               |
|----------------------------------|----------------------------------|--------------------------------------|
| `[[1, 4], [3, 2], [4, 1]]`      | `[[3, 3], [3, 3]]`              | `[[15, 15], [15, 15], [15, 15]]`    |
| `[[2, 3, 2], [4, 2, 4], [3, 1, 4]]` | `[[5, 4, 3], [2, 4, 1], [3, 1, 1]]` | `[[22, 22, 11], [36, 28, 18], [29, 20, 14]]` |


### 풀이설명
#### 행렬의 곱
A 행렬의 크기가 (M * K), B행렬의 크기가 (K * N) 일 때
두 행렬의 곱 연산은 행렬 A의 행의 개수 (K) 와 행렬 B의 열의 개수 (K) 를 기준으로 곱하기 때문에 행렬 곱 결과는 M * N 이 됩니다.



### 코드 설명
```java
class Solution {
    public int[][] solution(int[][] arr1, int[][] arr2) {
        // 행렬 arr1과 arr2의 행과 열의 수
        int r1 = arr1.length;
        int c1 = arr1[0].length;
        int r2 = arr2.length;
        int c2 = arr2[0].length;
        
        // 결과를 저장할 2차원 배열 초기화
        int[][] answer = new int[r1][c2];
        
        // 첫 번째 행렬 arr1의 각 행과 두번째 행렬 arr2의 각 열에 대해
        for (int i =0; i < r1; i++) {
            for (int j = 0; j < c2; j++) {
                // 두 행렬의 데이터를 곱해 결과 리스트에 더함
                for(int k = 0; k < c1; k++) {
                    answer[i][j] += arr1[i][k] * arr2[k][j];   
                }
            }
        }
        return answer;
    }
}
```

### 코드실행 흐름
- 결과 행렬의 크기는 r1 * c2 이므로 해당 크기의 배열을 미리 만들어 줍니다.
- arr1과 arr2의 행렬을 곱하기 위한 반복문을 수행합니다.
- 첫 번째 행렬의 i 번째 행과 두 번째 행렬의 j번째 열을 곱합니다.
- 마지막 반복문에서 곱 연산을 수행하며 answer 배열에 데이터를 저장합니다.

### 시간복잡도
행렬 곱셈에서 각 요소는 첫 번째 행렬 arr1의 한 행과 두 번째 행렬 arr2의 한 열의 곱과 합으로 계산됩니다.
따라서, 최악의 경우 시간 복잡도는 **O(n³)** 입니다.


### 결론
수학의 행렬 곱셈을 그대로 구현하면 됩니다.
두 배열의 최대 데이터 개수가 100이므로 시간 복잡도는 신경쓰지 않았습니다.
