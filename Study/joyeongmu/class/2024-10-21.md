

### **재귀(Recursion)**
> **순환**: 함수가 자기 자신을 호출해서 문제를 해결하는 프로그래밍 방식

---

### **핵심 개념**
- **종료 조건 (기저 조건: Base Case)**
    - 재귀 호출을 멈추는 조건
    - 재귀 함수가 무한히 자기 자신을 호출하는 것을 방지하기 위해 필수
    - 종료 조건을 만족하면 함수는 더 이상 자기 자신을 호출하지 않고 결과를 반환

- **재귀 단계 (Recursive Step)**
    - 문제를 더 작은 부분으로 나누어 자기 자신을 호출해 해결하는 과정
    - 문제의 규모를 줄여가며 종료 조건에 다가감
    - **재귀 알고리즘**의 핵심: 큰 문제를 유사한 작은 문제들로 나누어 해결

---

### **예시: 팩토리얼 함수**
- **팩토리얼**: `n! = n * (n-1) * (n-2) * … * 1`
    - `0! = 1` // `0!`은 0이 아닌 1
    - `n! = n * (n-1)!`

```java
public int factorial(int n){
    // 1. 종료 조건: n이 1 이하일 때
    if (n <= 1) {
        return 1;
    }
    // 2. 재귀 단계: n! = n * (n-1)!
    else {
        return n * factorial(n - 1);
    }
}
```

---

### **작동 방식**
- **스택 프레임**: 재귀 호출 과정에서 함수의 정보를 저장하는 공간
    - 호출된 함수의 정보는 스택 프레임에 쌓이고, 함수가 종료되면 스택 프레임에서 제거
    - **스택 프레임에 저장되는 정보**:
        - 함수 이름
        - 매개변수
        - 지역변수
        - 반환주소

---

### **사용 시 주의사항**
- **무한 재귀 방지**:
    - 적절한 **종료 조건**을 설정
    - 문제의 규모가 점차 줄어들도록 재귀 단계를 설계
- **재귀와 반복문 비교**:
    - 재귀는 반복문으로 변경 가능, 반대로 모든 반복문은 재귀로 표현 가능
    - 재귀는 **직관적이고 이해하기 쉬운 코드**를 작성하는 데 유리
    - 하지만 **메서드 호출에 따른 오버헤드**가 발생할 수 있음
    - 메서드 호출 과정에서 매개변수 전달 등 스택 프레임에 정보가 쌓이고 제거됨

---

### **장점**
- 복잡한 문제를 간단하게 표현 가능
- 반복문보다 코드가 간결하고 이해하기 쉬워짐

### **단점**
- 함수 호출에 따른 **오버헤드 발생** 가능
- **스택 오버플로우** 발생 위험

---

### **[ 예제 ] 문자열 뒤집기 메서드**
- 재귀를 이용한 문자열 뒤집기 코드 예시 (직접 코드 작성 가능)

---

### **Recursion vs. Iteration (재귀 vs 반복문)**
- **모든 재귀 호출은 반복문(iteration)으로 변경 가능**
- **모든 반복문은 재귀 호출(recursion)로 표현 가능**
- 재귀 호출(recursion)은 복잡한 알고리즘을 단순하고 이해하기 쉽게 표현 가능
- 하지만, 메서드 호출에 따른 오버헤드가 있음

---

### **재귀 사용 시 중요한 점**
- **종료 조건(기저 조건: Base Case)**을 정확하게 명시
    - 재귀 호출의 종료 조건은 재귀가 언젠가 멈추게 만드는 조건입니다.
    - 일반적으로, 문제의 규모가 충분히 작아져 더 이상 나눌 수 없거나 답을 직접 알 수 있는 경우에 해당합니다.
- **메서드 매개변수를 명시적으로 표현**
    - 재귀 함수의 매개변수는 재귀의 각 단계에서 함수가 작업할 데이터의 범위나 현재 상태를 나타냅니다.
    - 매개변수를 통해 각 단계의 문제를 명확하게 정의하고, 재귀 호출이 다음 단계로 올바르게 진행되도록 합니다.

---

```java
// 하노이의 탑 예제 코드
import java.util.*;

class Solution {
    private ArrayList<int[]> moveList = new ArrayList<>();
    
    public int[][] solution(int n) {
        hanoi(n, 1, 3, 2);
        return moveList.stream().toArray(int[][]::new);
    }
    
    /* n: 원판 수, from: 시작 기둥, to: 목표 기둥, middle: 중간 기둥 */
    private void hanoi(int n, int from, int to, int middle) {
        if (n == 1) { // 종료 조건: 목표 기둥에 옮기기만 하면 됨
            moveList.add(new int[]{from, to});
            return;
        }
        
        // 시작기둥에서 n-1개의 원판을 중간 기둥으로 옮김
        hanoi(n - 1, from, middle, to);
        
        // 시작기둥에서 가장 큰 원판을 목표 기둥으로 옮김
        moveList.add(new int[]{from, to});
        
        // 중간기둥에서 n-1개의 원판을 목표 기둥으로 옮김
        hanoi(n - 1, middle, to, from);
    }
}
```

