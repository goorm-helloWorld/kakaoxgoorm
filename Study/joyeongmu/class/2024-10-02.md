


### 자료구조와 알고리즘

#### 1. 자료구조 개요
**정의**: 데이터를 효율적으로 구성하고 관리하는 방법.

- **선형 자료구조**: 순서대로 데이터를 나열 (예: 배열, 연결 리스트)
- **비선형 자료구조**: 관련된 데이터끼리 묶음 관리 (예: 트리, 그래프)

#### 2. 정적 자료구조 vs 동적 자료구조
- **정적 자료구조**: 크기가 고정된 데이터 구조 (예: 배열)
    - 장점: 메모리 고정, 빠른 접근 속도
    - 단점: 크기 제한, 메모리 낭비 가능
- **동적 자료구조**: 크기를 유동적으로 조절 가능한 구조 (예: 연결 리스트)
    - 장점: 효율적인 메모리 사용
    - 단점: 오버헤드 발생 가능, 복잡성 증가

#### 3. CRUD 작업
데이터 구조에서 수행할 수 있는 기본 작업:
- **Create**: 새로운 데이터 추가
- **Read**: 저장된 데이터 읽기
- **Update**: 데이터 변경
- **Delete**: 불필요한 데이터 삭제

---

### 알고리즘 개요
**정의**: 데이터에 대해 CRUD 작업을 수행하는 방법과 절차.

- **정렬 알고리즘**: 버블 정렬, 퀵 정렬 등
- **탐색 알고리즘**: 원하는 데이터를 찾는 방법

#### 1. 시간 복잡도
**정의**: 알고리즘의 성능을 입출력 크기에 따라 예측하는 기준.
- **Big-O 표기법**: O(1), O(log n), O(n), O(n log n), O(n²), O(2^n), O(n!)
    - **O(1)**: 상수 시간 (예: 배열 인덱스 접근)
    - **O(log n)**: 로그 시간 (예: 이진 탐색)
    - **O(n)**: 선형 시간 (예: 리스트 순차 탐색)


### JAVA 컬렉션 프레임워크 소개

Java 컬렉션 프레임워크는 데이터를 저장, 처리, 조작할 수 있는 다양한 클래스와 인터페이스를 제공합니다.

| 자료구조 | 특징 | 장점 | 단점 | 활용점 |
|----------|------|------|------|--------|
| 배열 | 고정된 크기의 연속적인 메모리 공간에 데이터를 저장 | 빠른 인덱스 접근, 메모리 사용이 효율적 | 크기 변경 불가, 크기 예측이 어려울 때 비효율적 | 크기가 고정된 데이터를 다룰 때, 빠른 요소 접근이 필요할 때 |
| 리스트 (List) | 순서가 있는 데이터의 집합. 크기 변경 가능 | 데이터의 동적 추가, 삭제 용이, 순서 유지 | 데이터 접근 속도가 배열보다 느림 | 데이터의 개수가 변할 때, 순서가 중요한 데이터 관리 |
| Map | 키와 값 쌍으로 데이터를 저장, 키는 중복 불가 | 빠른 검색 및 접근, 키를 통한 데이터 관리 | 순서 유지 불가, 키의 중복 관리 필요 | 고유한 식별자로 데이터 관리 필요 시, 빠른 데이터 검색 및 접근 |
| Set | 중복을 허용하지 않는 데이터 집합 | 데이터 중복 방지, 집합 연산 지원 | 순서 유지 불가, 인덱스 접근 불가 | 중복 없는 데이터 관리, 집합 연산 (교집합, 합집합 등) |
| Stack | LIFO (Last In First Out) 구조의 데이터 집합 | 후입선출 방식 관리, 후행 작업에 유용 | 무작위 접근 불가 | 깊이 우선 탐색(DFS), 함수 호출 시 파라미터 및 로컬 변수 저장 |
| Queue | FIFO (First In First Out) 구조의 데이터 집합 | 순서대로 데이터 처리, 데이터 스트림 처리에 적합 | 무작위 접근 불가 | 작업 스케줄링, BFS(너비 우선 탐색) 알고리즘 |
| Deque | 양방향 큐 구조로 데이터를 양쪽 끝에서 추가/삭제 가능 | 양쪽 끝에서의 데이터 추가 및 제거 가능, 스택과 큐의 기능 모두 지원 | 특정 구현체(ArrayDeque)는 크기 조정 시 성능 저하 가능성 | 양방향 탐색 필요할 때, 스택 또는 큐로의 유연한 사용 필요할 때 |

---

---

### Java 컬렉션 프레임워크
**정의**: 데이터를 저장하고 조작하기 위한 클래스와 인터페이스 모음.

#### 1. List
- 순서를 유지하며 중복을 허용하는 데이터 구조.
- 주요 구현체: ArrayList, LinkedList

**ArrayList**
- 특징: 동적 크기 조절 가능, 인덱스 기반 접근
- 단점: 중간 삽입/삭제 성능 저하

**LinkedList**
- 특징: 이중 연결 리스트, 삽입/삭제가 빠름
- 단점: 인덱스 접근이 느림


### ArrayList vs LinkedList

| 기준 | ArrayList | LinkedList |
|------|-----------|------------|
| 내부 구조 | 동적 배열을 사용 | 이중 연결 리스트를 사용 |
| 요소 접근 | 인덱스를 통한 빠른 임의 접근 가능 (O(1)) | 순차 접근 필요. 인덱스 접근 시 O(n)의 시간이 소요됨 |
| 요소 추가/삭제 | 리스트의 끝에 요소를 추가/삭제하는 작업은 빠르나, 중간에 추가/삭제 시 배열을 재조정해야 하므로 비용이 많이 듦 | 요소의 추가 및 삭제가 빠르며, 특히 리스트의 시작 또는 끝에서의 작업이 매우 효율적임 |
| 메모리 사용 | 고정 크기의 배열을 사용하므로, 크기 조정 시 추가 메모리가 잠시 필요할 수 있지만 전반적으로 메모리 사용은 효율적임 | 각 요소마다 추가적인 메모리(이전 및 다음 요소에 대한 참조)가 필요하며, 전반적인 메모리 사용이 더 많음 |
| 사용 사례 | 임의 접근이 빈번하거나, 요소의 추가/삭제가 주로 리스트의 끝에서 일어나는 경우에 적합 | 요소의 추가/삭제가 리스트의 중간이나 시작, 끝에서 자주 발생하며, 순차 접근이 주로 필요한 경우에 적합 |

### 코딩 테스트와 알고리즘
- **코딩 테스트 사이트**
    - 백준: https://www.acmicpc.net/
    - 프로그래머스: https://programmers.co.kr/
    - 릿코드: https://leetcode.com/

#### 1. 알고리즘 문제 해결 과정
1. 문제 이해
2. 효율적이고 정확한 해결 방법 찾기
3. 프로그래밍으로 구현

---





