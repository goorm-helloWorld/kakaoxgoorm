## Q. 제너릭(Generic)이란?
제너릭은 클래스나 메서드를 선언할 때 **데이터 타입을 특정하지 않고**, 타입 파라미터를 통해 여러 타입을 다룰 수 있도록 하는 기법입니다. 이를 통해 코드 재사용성과 타입 안전성을 높일 수 있습니다.

## Q. 제너릭 타입을 사용하는 경우와 그렇지 않은 경우의 차이점은 무엇인가요?
1. **제너릭 미사용**:
    - 모든 데이터가 `Object` 타입으로 처리되므로, 데이터를 가져올 때마다 강제 타입 변환(casting)이 필요합니다.
    - 잘못된 타입이 들어가더라도 컴파일 시점에 오류가 발생하지 않으며, 런타임에 오류가 발생할 수 있습니다.
    - 코드 가독성과 안정성이 떨어집니다.

   **예시:**
   ```java
   List list = new ArrayList();
   list.add("hello");
   String str = (String) list.get(0);  // 강제 타입 변환 필요
   ```

2. **제너릭 사용**:
    - 타입 파라미터를 지정함으로써 강제 타입 변환이 불필요해지고, 코드의 가독성과 안정성이 높아집니다.
    - 컴파일 시점에 타입 검사를 통해 오류를 사전에 방지할 수 있습니다.

   **예시:**
   ```java
   List<String> list = new ArrayList<String>();
   list.add("hello");
   String str = list.get(0);  // 강제 타입 변환 불필요
   ```

### 결론:
- 제너릭을 사용하면 명확한 타입을 지정할 수 있어, 코드의 **안전성**과 **가독성**이 높아집니다.
- 제너릭을 사용하지 않으면 런타임에 타입 오류가 발생할 수 있으며, 코드 유지보수가 어려워질 수 있습니다.

---

### 1. 제네릭(Generic) 개요

제네릭은 클래스나 메서드를 **타입 파라미터**를 사용하여 선언하는 기법입니다. 이 기법을 통해 **타입 안정성**을 제공하며 **형변환**의 필요성을 줄여 코드의 안전성과 간결성을 높입니다. 제네릭은 **모든 종류의 타입**을 다룰 수 있어 코드의 재사용성을 증가시키는 장점이 있습니다.

```java
// 제네릭 클래스의 예
public class 클래스명<T> {...}
public interface 인터페이스명<T> {...}

// 사용 예
Gen<String> gen = new Gen<String>();
Gen<Integer> gen2 = new Gen<Integer>();
```

---

### 2. 제네릭의 이점

1) **타입 안정성 제공**  
   제네릭을 사용하면 컴파일 시점에서 **타입 체크**가 가능해집니다. 이로 인해 실행 시 발생할 수 있는 타입 에러를 미리 방지할 수 있습니다.

2) **형변환 생략**  
   제네릭을 사용하면 불필요한 **강제 타입 변환**을 피할 수 있습니다. 이는 코드의 안전성과 가독성을 높이는 데 기여합니다.

```java
// 제네릭을 사용하지 않은 경우
List list = new ArrayList();
list.add("hello");
String str = (String) list.get(0);  // 강제 타입 변환 필요

// 제네릭을 사용하는 경우
List<String> list = new ArrayList<String>();
list.add("hello");
String str = list.get(0);  // 강제 타입 변환 불필요
```

---

### 3. 제네릭 클래스와 메서드

1) **제네릭 클래스**
   제네릭 클래스는 클래스 선언 시 특정 타입을 **타입 파라미터**로 정의하고, 이를 나중에 사용할 때 구체적인 타입으로 대체합니다.

```java
// 제네릭 클래스의 예
public class GBox<T> {
    private T t;
    public T getT() { return t; }
    public void setT(T t) { this.t = t; }
}

// 사용 예
GBox<String> box1 = new GBox<>();
box1.setT("hello");
String str = box1.getT();  // 강제 타입 변환 없음
```

2) **제네릭 메서드**
   제네릭 메서드는 메서드 선언 시 **타입 파라미터**를 추가하여 **타입에 의존하지 않는** 메서드를 만들 수 있습니다.

```java
public <T> void genericMethod(T param) {
    System.out.println(param);
}
```

---

### 4. 멀티 타입 파라미터

제네릭은 **두 개 이상의 타입 파라미터**를 사용할 수 있으며, 이를 통해 복잡한 구조를 다룰 수 있습니다.

```java
class Pair<K, V> {
    private K key;
    private V value;
    public Pair(K key, V value) { this.key = key; this.value = value; }
    public K getKey() { return key; }
    public V getValue() { return value; }
}
```

---

### 5. 와일드카드(Generic Wildcards)

와일드카드는 제네릭에서 **타입의 유연성**을 제공하는 기능으로, **?** 기호를 사용하여 **미정의 타입**을 나타냅니다. 와일드카드는 **상한** 또는 **하한** 경계를 지정할 수 있습니다.

1) **비제한 와일드카드**
   `?`는 임의의 타입을 나타내며, **어떠한 타입**이라도 가능함을 나타냅니다.

   ```java
   public void printBox(Box<?> box) {
       System.out.println(box.get());
   }
   ```

2) **상한 경계 와일드카드**
   `<? extends T>`는 **T 타입**과 그 **자손들**만 허용합니다.

   ```java
   public void printList(List<? extends Number> list) {
       for (Number num : list) {
           System.out.println(num);
       }
   }
   ```

3) **하한 경계 와일드카드**
   `<? super T>`는 **T 타입**과 그 **조상들**만 허용합니다.

   ```java
   public void addNumber(List<? super Integer> list) {
       list.add(10);
   }
   ```

---

### 6. 제네릭 배열 생성

Java에서는 **제네릭 배열**의 직접적인 생성을 허용하지 않습니다. 이는 런타임 시 타입 정보가 **소거**(Type Erasure)되기 때문에 발생하는 제한입니다.

```java
// 제네릭 배열 생성 불가
T[] array = new T[10];  // 컴파일 에러

// 해결 방법
List<T> list = new ArrayList<>();
```

---

### 7. 제네릭의 컴파일 이후 처리

Java 컴파일러는 제네릭 타입을 이용해 **컴파일 시 타입 체크**를 수행하고, 필요한 곳에 **형변환**을 자동으로 넣어줍니다. 컴파일 이후에는 **제네릭 타입 정보**가 제거되며, 이를 **타입 소거(Type Erasure)**라고 합니다. 제네릭 이전의 코드와 호환성을 유지하기 위함입니다.

---

### 8. 제네릭 예제

1) **제네릭을 사용하지 않은 경우**

```java
public class Box {
    private Object object;
    public Object getObject() { return object; }
    public void setObject(Object object) { this.object = object; }
}

public class Main {
    public static void main(String[] args) {
        Box box = new Box();
        box.setObject("String Value");
        String value = (String) box.getObject();  // 강제 타입 변환 필요
        System.out.println(value);
    }
}
```

2) **제네릭을 사용하는 경우**

```java
public class GBox<T> {
    private T t;
    public T getT() { return t; }
    public void setT(T t) { this.t = t; }
}

public class Main {
    public static void main(String[] args) {
        GBox<String> box = new GBox<>();
        box.setT("String Value");
        String value = box.getT();  // 강제 타입 변환 없음
        System.out.println(value);
    }
}
```