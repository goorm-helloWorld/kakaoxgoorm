### 3. 제네릭 클래스와 메서드

제네릭을 사용하면 **클래스**와 **메서드**에서 타입에 의존하지 않는 코드를 작성할 수 있습니다. 이를 통해 **타입 안정성**을 확보하면서도 **코드의 재사용성**을 높일 수 있으며, 다양한 데이터 타입을 유연하게 처리할 수 있게 됩니다. 제네릭 클래스와 제네릭 메서드는 각각 클래스와 메서드 레벨에서 제네릭을 적용하는 방식으로, **타입 파라미터**를 선언하고, 이를 기반으로 다양한 타입의 데이터를 처리할 수 있도록 설계됩니다.

---

### 1) **제네릭 클래스 (Generic Class)**

**제네릭 클래스**는 클래스 선언 시 **타입 파라미터**를 정의하고, 이를 통해 클래스 내에서 사용되는 데이터 타입을 **동적으로 지정**할 수 있습니다. 즉, **제네릭 클래스**는 다양한 타입의 데이터를 처리할 수 있는 **유연한 클래스**를 만드는 기법입니다.

#### 예시: 제네릭 클래스 선언
```java
public class GBox<T> {  // 'T'는 타입 파라미터
    private T t;

    public T getT() {
        return t;  // 'T' 타입의 값을 반환
    }

    public void setT(T t) {
        this.t = t;  // 'T' 타입의 값을 설정
    }
}
```

위 코드에서 `GBox` 클래스는 **타입 파라미터 T**를 사용합니다. 이를 통해 `GBox` 클래스는 **어떤 타입의 데이터도 저장**할 수 있는 **유연한 클래스**가 됩니다. `T`는 **타입 파라미터**로, 제네릭 클래스 선언 시 데이터 타입이 아직 결정되지 않았음을 의미합니다. **실제 사용 시점**에 `T`는 **구체적인 타입**으로 지정됩니다.

#### 예시: 제네릭 클래스 사용
```java
// String 타입을 사용하는 GBox 인스턴스 생성
GBox<String> box1 = new GBox<>();
box1.setT("hello");  // 'T'는 String으로 대체됨
String str = box1.getT();  // 강제 타입 변환이 필요 없음

// Integer 타입을 사용하는 GBox 인스턴스 생성
GBox<Integer> box2 = new GBox<>();
box2.setT(100);  // 'T'는 Integer로 대체됨
Integer num = box2.getT();  // 강제 타입 변환이 필요 없음
```

위 예제에서 `GBox<String>`과 `GBox<Integer>`는 **제네릭 클래스**를 각각 **String**과 **Integer** 타입으로 사용하는 예시입니다. `T`는 사용 시점에서 `String` 또는 `Integer` 타입으로 **구체화**되며, 이를 통해 **타입 안정성**을 유지하면서도 **유연하게** 다양한 타입의 데이터를 처리할 수 있습니다.

#### 제네릭 클래스의 장점

1. **유연성**: 하나의 제네릭 클래스를 작성하면 **다양한 타입**을 처리할 수 있어, **코드 재사용성**이 높아집니다.
2. **타입 안정성**: 타입 파라미터를 통해 컴파일 시점에 **타입 체크**가 이루어지므로, 런타임 에러를 줄일 수 있습니다.
3. **형 변환 불필요**: 제네릭을 사용하면 **형 변환** 없이 타입을 사용할 수 있어, 코드의 **안정성**과 **가독성**이 높아집니다.

---

### 2) **제네릭 메서드 (Generic Method)**

**제네릭 메서드**는 **메서드** 차원에서 **타입 파라미터**를 사용하는 메서드입니다. 제네릭 클래스와 달리, 제네릭 메서드는 **메서드 레벨**에서만 타입 파라미터를 사용하며, **메서드 선언부**에 타입 파라미터를 지정합니다. 이를 통해 **메서드가 독립적으로 다양한 타입을 처리**할 수 있도록 합니다.

#### 제네릭 메서드의 선언
제네릭 메서드는 메서드 선언 시 타입 파라미터를 추가로 선언하며, 메서드의 **반환 타입** 바로 앞에 **타입 파라미터**를 명시합니다.

```java
public class Utility {
    // 제네릭 메서드 선언: <T>는 타입 파라미터
    public static <T> void printItem(T item) {
        System.out.println(item);
    }
}
```

위 코드에서 `printItem` 메서드는 **타입 파라미터 T**를 사용한 **제네릭 메서드**입니다. 이 메서드는 **어떠한 타입의 데이터**도 처리할 수 있으며, **타입에 구애받지 않는 메서드**를 만들 수 있습니다.

#### 제네릭 메서드의 사용
```java
Utility.printItem("Hello");  // String 타입으로 호출
Utility.printItem(123);      // Integer 타입으로 호출
Utility.printItem(45.67);    // Double 타입으로 호출
```

위 예시에서 `printItem` 메서드는 호출될 때마다 **타입 파라미터 T**가 각각 **String**, **Integer**, **Double**로 **자동으로 대체**됩니다. 이를 통해 **하나의 메서드로 여러 타입을 처리**할 수 있습니다.

---

### 3) **제네릭 메서드와 제네릭 클래스의 차이점**

**제네릭 클래스**와 **제네릭 메서드**는 모두 타입 파라미터를 사용하여 다양한 타입을 처리할 수 있다는 공통점이 있지만, 사용되는 범위와 방식에 차이가 있습니다.

1. **제네릭 클래스**는 **클래스 전체**에 걸쳐 **타입 파라미터**를 사용하며, 클래스 내의 모든 필드와 메서드에서 **일관된 타입**으로 동작합니다. 제네릭 클래스는 클래스를 인스턴스화할 때 **타입이 결정**됩니다.

2. **제네릭 메서드**는 **메서드 선언부**에서 **타입 파라미터**를 지정하며, 메서드가 호출될 때 **타입이 결정**됩니다. 제네릭 메서드는 **클래스 전체가 아닌, 특정 메서드**에만 제네릭을 적용할 수 있다는 장점이 있습니다.

#### 제네릭 클래스와 제네릭 메서드의 예시
```java
// 제네릭 클래스
public class GBox<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

// 제네릭 메서드
public class Utility {
    public static <T> void printItem(T item) {
        System.out.println(item);
    }
}
```

위 코드에서 `GBox`는 제네릭 클래스이며, `Utility` 클래스의 `printItem` 메서드는 **제네릭 메서드**입니다. **GBox 클래스**는 **T** 타입 파라미터로 선언된 클래스이며, 이 클래스의 인스턴스를 생성할 때 타입이 결정됩니다. 반면에 **printItem** 메서드는 **메서드 호출 시** 타입이 결정되며, 각각의 호출에서 다른 타입을 사용할 수 있습니다.

---

### 4) **제네릭 메서드와 제네릭 클래스의 상호작용**

제네릭 메서드는 제네릭 클래스 내에서도 사용할 수 있습니다. 제네릭 클래스 내에서 제네릭 메서드를 정의하면, 클래스의 **타입 파라미터**와 **메서드의 타입 파라미터**가 **독립적으로** 동작할 수 있습니다. 이는 클래스의 타입과 상관없이 메서드가 **독립적으로 다른 타입**을 처리할 수 있도록 유연성을 제공합니다.

#### 예시: 제네릭 클래스 내의 제네릭 메서드
```java
public class GBox<T> {
    private T item;

    public T getItem() {
        return item;
    }

    public void setItem(T item) {
        this.item = item;
    }

    // 제네릭 메서드
    public <U> void displayItem(U item) {
        System.out.println("Displaying item: " + item);
    }
}
```

위 코드에서 `GBox<T>` 클래스는 **타입 파라미터 T**를 사용하는 **제네릭 클래스**이며, 이 클래스 내에서 `displayItem` 메서드는 **타입 파라미터 U**를 사용하는 **제네릭 메서드**입니다. 이로 인해 **GBox 클래스의 타입 T**와 **제네릭 메서드의 타입 U**는 **서로 독립적**으로 동작할 수 있습니다.

#### 제네릭 클래스 내 제네릭 메서드의 사용
```java
GBox<String> box = new GBox<>();
box.setItem("Hello");

// 제네릭 메서드 호출 (타입 U는 Integer)
box.displayItem(100);  // Output: Displaying item: 100

// 제네릭 메서드 호출 (타입 U는 Double)
box.displayItem(45.67);  // Output: Displaying item:

 45.67
```

위 예시에서 `GBox<String>` 클래스는 **String** 타입으로 선언되었지만, `displayItem` 메서드는 **Integer**나 **Double** 타입을 받아 처리할 수 있습니다. 이처럼 **제네릭 클래스**와 **제네릭 메서드**는 **서로 다른 타입**으로 동작하며, 높은 유연성을 제공합니다.

---

### 결론

**제네릭 클래스**와 **제네릭 메서드**는 자바에서 **타입 안정성을 보장**하면서도 **코드의 재사용성을 극대화**할 수 있는 중요한 기능입니다. 제네릭을 사용하면 **컴파일 시점**에 **타입 체크**를 통해 **안전한 코드**를 작성할 수 있으며, **형 변환의 필요성**을 줄여 코드를 더욱 **간결**하고 **유지보수 가능**하게 만듭니다.

**제네릭 클래스**는 클래스 전체에서 **타입 파라미터**를 사용하여 유연한 구조를 제공하며, **제네릭 메서드**는 특정 메서드에서만 **다양한 타입**을 처리할 수 있는 능력을 부여합니다. 이 두 기능을 적절히 활용하면 자바 프로그램에서 **안정성**과 **효율성**을 동시에 달성할 수 있습니다.