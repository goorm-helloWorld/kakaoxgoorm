### 5. 제네릭 와일드카드 (Generic Wildcards)

**와일드카드(Wildcards)**는 제네릭에서 **유연성**을 제공하는 기능으로, **`?`** 기호를 사용하여 **미정의 타입**을 나타냅니다. 이를 통해 제네릭 타입을 **더욱 범용적으로 사용**할 수 있으며, 여러 타입을 허용하거나 **상한/하한 경계**를 설정하여 제네릭 타입을 제한적으로 사용할 수 있습니다. 와일드카드는 **상한 경계**(Upper Bound)와 **하한 경계**(Lower Bound)를 설정할 수 있으며, 이를 통해 다양한 클래스 간의 관계를 유연하게 처리할 수 있습니다.

---

### 1) 와일드카드의 필요성

제네릭을 사용하면서도 **불특정 타입**을 처리하거나 **특정 타입 계층만 허용**하고자 할 때 와일드카드를 사용합니다. 제네릭은 특정 타입으로 한정되기 때문에 **모든 타입**을 다루는 데 한계가 있을 수 있습니다. 이때 와일드카드는 **어떤 타입이라도 처리**할 수 있도록 하거나, 특정 **상위 타입** 또는 **하위 타입**만을 처리할 수 있도록 도와줍니다.

와일드카드는 크게 **비제한 와일드카드**(Unbounded Wildcards), **상한 경계 와일드카드**(Upper Bounded Wildcards), **하한 경계 와일드카드**(Lower Bounded Wildcards)로 나뉩니다.

---

### 2) 비제한 와일드카드 (Unbounded Wildcards)

**비제한 와일드카드**는 **모든 타입**을 허용하는 와일드카드입니다. **`?`**를 사용하여, **어떠한 타입**도 처리할 수 있다는 것을 나타냅니다. 비제한 와일드카드는 **타입이 불분명하거나 특정할 필요가 없을 때** 사용됩니다.

예를 들어, **어떠한 타입의 리스트**라도 처리할 수 있는 메서드를 작성할 때 비제한 와일드카드를 사용합니다.

#### 예시: 비제한 와일드카드 사용
```java
// 어떤 타입의 리스트도 받아서 처리하는 메서드
public static void printList(List<?> list) {
    for (Object element : list) {
        System.out.println(element);
    }
}
```

위 메서드는 **모든 타입의 리스트**를 처리할 수 있습니다. **제네릭 타입을 미리 알 수 없을 때** 또는 **제한하지 않고** 다양한 타입을 다루고 싶을 때 유용합니다. **비제한 와일드카드**를 사용하면 **타입에 구애받지 않고** 코드의 유연성을 높일 수 있습니다.

---

### 3) 상한 경계 와일드카드 (Upper Bounded Wildcards)

**상한 경계 와일드카드**는 특정 타입의 **상위 클래스나 인터페이스의 자식 타입**들만 허용하는 와일드카드입니다. 상한 경계는 **`<? extends T>`** 형태로 사용되며, 이는 **T 타입**을 **상위 타입**으로 하고 **T의 자손들만 허용**한다는 뜻입니다.

상한 경계 와일드카드는 **하위 클래스만 허용하고** 상위 클래스는 허용하지 않는 경우에 유용합니다. 이를 통해 제네릭 타입을 제한하여, 특정 상위 클래스나 인터페이스를 구현한 **자식 클래스들만** 다룰 수 있게 됩니다.

#### 예시: 상한 경계 와일드카드 사용
```java
// Number 클래스와 그 하위 클래스들만 허용하는 메서드
public static void processNumbers(List<? extends Number> list) {
    for (Number number : list) {
        System.out.println(number);
    }
}
```

위 예제에서 **`<? extends Number>`**는 **Number 클래스**와 **그 하위 클래스**인 **Integer**, **Double**, **Float** 등을 모두 처리할 수 있습니다. 이처럼 **상한 경계**를 사용하면 특정 상위 클래스에 대해 **하위 클래스들만 허용**할 수 있게 됩니다.

#### 예시: 상한 경계 와일드카드의 사용 예
```java
List<Integer> intList = Arrays.asList(1, 2, 3);
List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.3);

processNumbers(intList);   // 정상 실행: Integer는 Number의 하위 클래스
processNumbers(doubleList);  // 정상 실행: Double도 Number의 하위 클래스
```

위의 코드에서는 **`processNumbers`** 메서드가 **Integer**와 **Double** 리스트를 모두 처리할 수 있습니다. 이처럼 **상한 경계 와일드카드**는 **특정 계층 내의 타입**을 다룰 때 유용합니다.

---

### 4) 하한 경계 와일드카드 (Lower Bounded Wildcards)

**하한 경계 와일드카드**는 특정 타입의 **상위 클래스**만 허용하는 와일드카드입니다. 하한 경계는 **`<? super T>`** 형태로 사용되며, 이는 **T 타입**을 **하위 타입**으로 하고 **T의 상위 클래스만 허용**한다는 뜻입니다.

하한 경계 와일드카드는 **상위 클래스만 허용**하고 **하위 클래스**는 허용하지 않는 경우에 유용합니다. 이를 통해 **하위 클래스**에서 상위 클래스로 **타입 변환**을 유연하게 처리할 수 있습니다.

#### 예시: 하한 경계 와일드카드 사용
```java
// Integer와 그 상위 클래스만 허용하는 메서드
public static void addNumbers(List<? super Integer> list) {
    list.add(10);
}
```

위 예제에서 **`<? super Integer>`**는 **Integer 클래스**와 그 **상위 클래스**인 **Number**, **Object**를 허용합니다. 이 메서드는 리스트에 **Integer** 값을 추가할 수 있지만, 더 상위 클래스 타입으로 저장된 요소를 다룰 수 있습니다.

#### 예시: 하한 경계 와일드카드의 사용 예
```java
List<Object> objList = new ArrayList<>();
List<Number> numList = new ArrayList<>();

addNumbers(objList);   // 정상 실행: Object는 Integer의 상위 클래스
addNumbers(numList);   // 정상 실행: Number도 Integer의 상위 클래스
```

위 코드에서는 **`addNumbers`** 메서드가 **Object**와 **Number** 리스트에 **Integer 값을 추가**하는 데 문제가 없습니다. 이처럼 **하한 경계 와일드카드**는 **상위 클래스에 제한**을 두고 싶을 때 유용합니다.

---

### 5) 비제한 와일드카드의 제약

**비제한 와일드카드**를 사용할 때는 몇 가지 **제약**이 있습니다. **비제한 와일드카드**는 **타입을 알 수 없기 때문에** 일부 연산은 허용되지 않습니다. 특히, **컬렉션에 요소를 추가**하는 연산은 **허용되지 않으며**, 이는 컴파일러가 구체적인 타입을 알 수 없기 때문입니다.

#### 예시: 비제한 와일드카드의 제약
```java
List<?> list = new ArrayList<String>();

list.add("Hello");  // 컴파일 에러 발생: 타입이 불확실하여 추가 불가
```

위 코드에서 `list`는 **비제한 와일드카드**로 선언되어 있어 **타입이 불확실**합니다. 따라서, **새로운 요소를 추가**하려고 할 때 컴파일 에러가 발생합니다. 하지만, **요소를 읽는 작업**은 문제가 없으며, **와일드카드**로 선언된 리스트에서 **데이터를 읽는 것**은 가능합니다.

---

### 6) 상한/하한 경계 와일드카드에서의 제약

**상한 경계 와일드카드**와 **하한 경계 와일드카드**를 사용할 때도 몇 가지 **제약**이 있습니다. 특히, 상한 경계에서는 **새로운 요소를 추가할 수 없으며**, 하한 경계에서는 **원소를 꺼내는 작업에 제약**이 발생합니다.

#### 상한 경계에서의 제약
**상한 경계 와일드카드**는 **T 타입의 자식 클래스만** 허용하기 때문에, **새로운 요소를 추가**하는 것은 **제한**됩니다. 이는 **상한 경계가 타입을 구체적으로 제한**하기 때문에, **구체적인 타입**을 추가할 수 없다는 제약이 있습니다.

#### 예시: 상한 경계 와일드카드에서 추가 불가
```java
public static void addElement(List<? extends Number> list) {
    list.add(new Integer(10));  // 컴파일 에러 발생
}
```

위 예제에서 **`<? extends Number>`**는 **Number 클래스**와 그 **자손들만 허용**하지만, 리스트에 **새로운 요소를 추가

**하는 것은 불가능합니다. 이는 **상한 경계**로 인해 **타입이 명확하지 않기 때문에** 새로운 요소를 추가할 수 없습니다.

#### 하한 경계에서의 제약
**하한 경계 와일드카드**는 **T 타입의 상위 클래스만** 허용하기 때문에, **원소를 꺼내는 작업**에는 **제약**이 생길 수 있습니다. 하한 경계에서는 **타입을 명확히 알 수 없기 때문에**, **원소를 꺼내는 작업**에서 **캐스팅**이 필요할 수 있습니다.

#### 예시: 하한 경계 와일드카드에서 원소 읽기
```java
public static void printCollection(List<? super Integer> list) {
    // 읽어오는 요소는 Object로 처리됨
    for (Object item : list) {
        System.out.println(item);
    }
}
```

위 코드에서 **하한 경계 와일드카드**로 선언된 리스트에서 **데이터를 읽을 때**는 **Object 타입**으로 처리됩니다. 이는 **하한 경계**가 **상위 클래스**를 허용하기 때문에, **정확한 타입을 알 수 없어** 발생하는 제약입니다.

---

### 7) 제네릭 메서드와 와일드카드 메서드

**제네릭 메서드**는 메서드 선언부에 **타입 파라미터**를 명시하여 **다양한 타입**을 처리할 수 있는 메서드를 의미합니다. 반면, **와일드카드 메서드**는 **와일드카드**를 사용하여 **불특정 타입**을 처리하는 메서드를 의미합니다.

#### 예시: 제네릭 메서드
```java
public <T> void genericMethod(Box<T> box) {
    System.out.println("T = " + box.get());
}
```

위의 제네릭 메서드는 **타입 파라미터 T**를 사용하여 **Box 클래스의 타입에 상관없이** 처리할 수 있습니다.

#### 예시: 와일드카드 메서드
```java
public void wildcardMethod(Box<?> box) {
    System.out.println("? = " + box.get());
}
```

**와일드카드 메서드**는 **모든 타입**의 `Box`를 받아 처리할 수 있으며, **타입을 구체적으로 지정하지 않고** 사용할 수 있습니다.

---

### 결론

**와일드카드**는 제네릭에서 **유연성**을 제공하는 중요한 기능입니다. 이를 통해 **제네릭 타입**을 더욱 유연하게 사용하고, **상한 경계**와 **하한 경계**를 설정하여 **타입 안정성**을 유지할 수 있습니다.

- **비제한 와일드카드**는 **어떠한 타입**도 허용하여, **제네릭 타입의 유연성**을 극대화합니다.
- **상한 경계 와일드카드**는 **특정 상위 클래스**와 **그 하위 클래스들**만 허용하여, **하위 타입의 유연성**을 제공합니다.
- **하한 경계 와일드카드**는 **특정 하위 클래스**와 **그 상위 클래스들**만 허용하여, **상위 타입의 유연성**을 제공합니다.

이를 통해, **제네릭 타입**을 사용하는 코드는 더욱 **유연하고 재사용성**이 높아지며, **타입 안전성**을 유지하면서도 **다양한 타입**을 처리할 수 있습니다.