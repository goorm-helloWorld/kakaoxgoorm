### 7. 제네릭의 컴파일 이후 처리: 타입 소거 (Type Erasure)

**제네릭(Generic)**은 자바에서 타입 안전성을 높이고, 코드 재사용성을 증가시키는 중요한 기능입니다. 하지만 **제네릭**은 **컴파일 시점**에만 타입 정보를 유지하며, **런타임**에는 이 타입 정보가 **제거**됩니다. 이를 **타입 소거(Type Erasure)**라고 하며, 자바 컴파일러가 제네릭 타입을 처리하는 기본적인 방식입니다.

### 1) 제네릭의 컴파일 시 동작 원리

자바에서 제네릭이 도입된 이유는 코드의 **타입 안전성**을 보장하고, 다양한 타입을 처리할 수 있도록 하기 위함입니다. 제네릭을 사용하면, 코드 작성 시점에 타입을 명시하고, 컴파일러가 **타입 체크**를 통해 잘못된 타입 사용을 방지합니다. 하지만 자바의 제네릭은 **런타임 시점**에는 **타입 정보가 유지되지 않으며** 소거됩니다. 즉, 제네릭 타입은 **컴파일 시점**에서만 유효하며, **런타임**에는 **실제 타입 정보가 사라지고, 기본적으로 `Object`로 처리**됩니다.

#### 예시: 제네릭 타입 컴파일 전후
```java
// 제네릭 클래스
public class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

// 사용 예시
Box<String> stringBox = new Box<>();
stringBox.setItem("Hello");
String str = stringBox.getItem();
```

위 코드에서 `Box<String>` 클래스를 사용하고 있지만, **컴파일 이후**에는 `String` 타입 정보가 **소거**되어 **Object**로 대체됩니다. 이는 자바가 제네릭을 처리하는 방식이며, 제네릭 타입은 **컴파일 시점**에만 **타입 안정성**을 보장합니다.

### 2) 타입 소거(Type Erasure)란?

**타입 소거(Type Erasure)**는 자바 컴파일러가 제네릭 코드를 처리하는 방식으로, **제네릭 타입 정보**는 컴파일 이후에 제거되고, **기본적으로 `Object` 타입**으로 변환됩니다. 이를 통해 자바는 **제네릭 이전의 코드**와 **호환성**을 유지하면서도 **타입 안정성**을 제공할 수 있습니다.

#### 타입 소거의 동작 방식
1. **타입 변환**: 제네릭 타입을 사용하는 코드는 컴파일 시점에서 **타입 체크**를 수행하며, 이때 **잘못된 타입**이 사용되면 **컴파일 에러**가 발생합니다.
2. **형변환 추가**: 컴파일러는 제네릭 타입에 맞는 **형변환 코드**를 자동으로 추가하여, 런타임 시점에 **타입 변환**이 제대로 이루어지도록 합니다.
3. **타입 소거**: 제네릭 타입 정보는 **컴파일 후 제거**되며, **실제 타입**은 **`Object`**로 대체됩니다. 따라서 런타임 시점에서는 **제네릭 타입 정보**가 존재하지 않습니다.

#### 타입 소거의 예시
```java
// 제네릭 사용 예시
Box<String> stringBox = new Box<>();
stringBox.setItem("Hello");
String str = stringBox.getItem();
```

이 코드는 **컴파일 후** 다음과 같이 **타입 소거**가 이루어집니다:

```java
// 컴파일 후 타입 소거된 코드
Box stringBox = new Box();  // 제네릭 타입 정보 제거
stringBox.setItem("Hello");
String str = (String) stringBox.getItem();  // 컴파일러가 강제 형변환 추가
```

위 코드에서 컴파일러는 `Box<String>`을 **일반 객체 타입**으로 변환하고, `getItem()` 메서드 호출 시 **강제 형변환 코드**를 자동으로 추가합니다. 이로 인해, **타입 안정성**은 컴파일 시점에만 보장되며, 런타임에는 제네릭 타입이 존재하지 않게 됩니다.

### 3) 타입 소거의 이점

자바는 **타입 소거**를 통해 제네릭이 도입되기 이전의 **레거시 코드**와 **호환성**을 유지합니다. 자바는 제네릭 이전에 작성된 코드와의 **하위 호환성**을 유지하기 위해 **타입 소거**를 선택했습니다.

#### 타입 소거의 주요 이점:
1. **하위 호환성 유지**: 제네릭이 도입되기 전의 코드와 **호환성**을 유지할 수 있습니다. **레거시 코드**와 제네릭 코드를 함께 사용할 수 있으며, 기존 코드를 수정하지 않아도 됩니다.
2. **타입 안정성 제공**: 제네릭 타입을 사용하면 **컴파일 시점**에 **타입 체크**를 수행하여 잘못된 타입 사용을 방지할 수 있습니다. 이는 코드의 **안정성**을 높이고, **런타임 에러**를 줄이는 데 기여합니다.
3. **코드 간결성**: 제네릭은 **형변환**을 자동으로 처리하므로, 코드 작성 시 **불필요한 형변환**을 생략할 수 있습니다. 이는 코드의 가독성과 유지보수성을 높입니다.

---

### 4) 타입 소거의 한계

**타입 소거**는 제네릭의 강력한 기능을 제공하는 동시에, 몇 가지 **제한**과 **한계**를 가지고 있습니다. 특히, **런타임 시점**에서 제네릭 타입 정보를 사용할 수 없다는 점에서 몇 가지 불편함이 발생할 수 있습니다.

#### 4.1 런타임 시 타입 정보 상실

타입 소거는 **런타임 시점**에 **제네릭 타입 정보**가 제거되기 때문에, **런타임 타입 검사**나 **리플렉션(reflection)**을 사용할 때 제네릭 타입에 대한 정보를 얻을 수 없습니다. 이는 특정한 상황에서 **타입 캐스팅**이나 **타입 검사**가 필요한 경우 문제가 될 수 있습니다.

#### 예시: 런타임 시 타입 정보 상실
```java
List<String> list = new ArrayList<>();
if (list instanceof List<String>) {  // 컴파일 에러: 런타임에 제네릭 타입 정보 없음
    // ...
}
```

위 코드는 **런타임 시점**에 `List<String>` 타입을 **검사**하려고 하지만, **타입 소거**로 인해 **제네릭 타입 정보가 존재하지 않으므로** 컴파일 에러가 발생합니다.

#### 해결 방법: 와일드카드 사용
제네릭 타입을 **검사**하거나 **처리**할 때는 **와일드카드**를 사용하여 문제를 해결할 수 있습니다.

```java
if (list instanceof List<?>) {  // 와일드카드 사용하여 타입 검사 가능
    // ...
}
```

와일드카드를 사용하면 **제네릭 타입 정보**를 유지하지 않더라도 **타입 검사**를 수행할 수 있습니다.

---

#### 4.2 배열과 제네릭의 호환성 문제

자바는 **배열**과 **제네릭**을 동시에 사용할 때 **제약**이 있습니다. 제네릭 타입의 배열은 **런타임 타입 정보**를 유지하지 않기 때문에, **타입 안전성**을 보장할 수 없습니다. 이로 인해 **제네릭 배열 생성**은 허용되지 않으며, **배열과 제네릭**을 함께 사용하는 경우 주의가 필요합니다.

#### 예시: 제네릭 배열 생성 불가
```java
T[] array = new T[10];  // 컴파일 에러: 제네릭 배열 생성 불가
```

위 코드에서 **제네릭 배열 생성**이 불가능한 이유는 **타입 소거**로 인해 **런타임 타입 정보**를 알 수 없기 때문입니다. 이를 해결하기 위해서는 **리스트(List)**를 사용하는 방법이 일반적입니다.

---

### 5) 타입 소거와 리플렉션

리플렉션(reflection)을 사용할 때, **제네릭 타입**은 **런타임**에 **타입 소거**가 발생하므로 **실제 타입 정보**를 얻을 수 없습니다. **리플렉션**은 런타임에 객체의 메타데이터를 확인하는 기능이지만, 제네릭 타입은 **컴파일 시점에만 유효**하므로 **런타임**에 제네릭 타입 정보를 확인할 수 없습니다.

#### 해결 방법: Type Token 패턴

**Type Token 패턴**은 **런타임에 타입 정보를 유지**하기 위한 기법 중 하나입니다. 이를 통해 **리플렉션**과 **타입 소거** 문제를 해결할 수 있습니다.

#### 예시: Type Token 패턴
```java
public class GenericClass<T> {
    private Class<T> type;

    public GenericClass(Class<T> type) {
        this.type = type;
    }

    public Class<T

> getType() {
        return type;
    }
}
```

위의 코드에서 **Type Token 패턴**을 사용하면 **런타임**에 **제네릭 타입 정보**를 유지할 수 있습니다. 이는 리플렉션을 사용할 때 유용한 패턴입니다.

---

### 6) 결론

**타입 소거**는 자바에서 **제네릭**을 도입하면서도 **레거시 코드와의 호환성**을 유지하기 위한 중요한 기법입니다. 이를 통해 자바는 **타입 안전성**을 제공하면서도 **이전 코드**와의 **호환성**을 보장합니다. 하지만 **타입 소거**로 인해 **런타임 타입 정보 상실**과 같은 **제약**이 존재하므로, 이를 해결하기 위해 **와일드카드**, **Type Token 패턴** 등을 적절히 활용해야 합니다.