## Q. 컬렉션 프레임워크(Collection Framework)
컬렉션 프레임워크는 **다수의 객체를 효율적으로 저장하고 관리하기 위한 표준화된 프로그래밍 방식**입니다. `List`, `Set`, `Map` 등의 인터페이스와 그 구현체들을 제공합니다.

## Q. 컬렉션 프레임워크에서 List, Set, Map의 차이점
- **List**: 순서가 있는 데이터의 집합으로, 중복된 요소를 허용합니다. (예: ArrayList, LinkedList)
- **Set**: 순서가 없는 데이터의 집합으로, 중복을 허용하지 않습니다. (예: HashSet, TreeSet)
- **Map**: 키와 값의 쌍으로 데이터를 저장하며, 키는 중복을 허용하지 않지만 값은 중복될 수 있습니다. (예: HashMap, TreeMap)

## Q. Queue와 Stack의 차이점은 무엇인가요?
- **Queue**:
    - **FIFO(First In First Out)** 구조로, 먼저 들어온 데이터가 먼저 나가는 방식입니다.
    - 순차적인 작업 처리에 적합합니다. 예를 들어, **프린터 작업 대기열**이나 **프로세스 관리**에 주로 사용됩니다.
    - 주요 메서드:
        - `add()`: 요소를 큐의 끝에 추가.
        - `poll()`: 큐에서 첫 번째 요소를 제거하고 반환.
        - `peek()`: 큐에서 첫 번째 요소를 반환하지만 제거하지 않음.

  **Queue 예시**:
  ```java
  Queue<String> queue = new LinkedList<>();
  queue.add("First");
  queue.add("Second");
  queue.add("Third");

  System.out.println(queue.poll());  // 출력: First
  ```

- **Stack**:
    - **LIFO(Last In First Out)** 구조로, 나중에 들어온 데이터가 먼저 나가는 방식입니다.
    - 후입선출 방식의 작업 처리에 적합합니다. 예를 들어, **함수 호출 스택**이나 **되돌리기 기능(Undo)** 등에 사용됩니다.
    - 주요 메서드:
        - `push()`: 스택에 요소 추가.
        - `pop()`: 스택에서 마지막에 추가된 요소를 제거하고 반환.
        - `peek()`: 스택에서 마지막에 추가된 요소를 반환하지만 제거하지 않음.

  **Stack 예시**:
  ```java
  Stack<String> stack = new Stack<>();
  stack.push("First");
  stack.push("Second");
  stack.push("Third");

  System.out.println(stack.pop());  // 출력: Third
  ```

### 차이점 요약:
- **Queue**는 **FIFO(First In First Out)** 구조로 먼저 들어온 데이터가 먼저 나가는 방식입니다.
- **Stack**은 **LIFO(Last In First Out)** 구조로 나중에 들어온 데이터가 먼저 나가는 방식입니다.
- Queue는 **순차적 작업 처리**에, Stack은 **후입선출 방식의 작업 처리**에 적합합니다.

## Q. Iterator는 무엇이며, 언제 사용하나요?
- **Iterator**는 컬렉션의 요소를 순차적으로 접근하는 데 사용되는 **인터페이스**입니다.
- 컬렉션의 **내부 구조**를 몰라도 요소를 하나씩 가져올 수 있으며, 특히 **순차적으로 탐색**하거나 **삭제**할 때 유용합니다.
- `Iterator`는 **컬렉션 프레임워크**에 속한 `List`, `Set`, `Map` 등의 데이터를 순차적으로 처리할 수 있는 방법을 제공합니다.

### 주요 메서드:
1. `hasNext()`: 다음 요소가 있는지 여부를 확인합니다. (boolean 반환)
2. `next()`: 다음 요소를 반환합니다.
3. `remove()`: 현재 요소를 컬렉션에서 삭제합니다. (삭제는 한 번만 가능합니다)

### 예시 코드:
```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class IteratorExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        // Iterator를 사용하여 요소 순회
        Iterator<String> iterator = list.iterator();
        
        while (iterator.hasNext()) {
            String element = iterator.next();
            System.out.println(element);
            
            // 요소 삭제
            if ("B".equals(element)) {
                iterator.remove();  // "B" 요소 삭제
            }
        }

        // 삭제 후 리스트 출력
        System.out.println("After removal: " + list);  // 출력: [A, C]
    }
}
```

### 결론:
- **Iterator**는 컬렉션을 순차적으로 탐색하면서 요소를 안전하게 제거할 수 있는 방법을 제공합니다.
- **내부 구조**에 의존하지 않고 컬렉션의 요소에 접근할 수 있으며, 반복문보다 더 **유연한 제어**가 가능합니다.

---

