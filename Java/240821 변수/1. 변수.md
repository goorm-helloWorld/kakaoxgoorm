## Q. Java의 프리미티브 타입과 레퍼런스 타입의 차이점
프리미티브 타입은 `int`, `float`, `boolean` 등과 같은 기본 데이터 타입으로, 값 자체를 저장합니다. 반면, 레퍼런스 타입은 객체의 주소를 저장하며, 예를 들어 `String`이나 배열 등이 이에 해당합니다.

## Q. int와 Integer의 차이점
`int`는 Java의 프리미티브 타입으로 값 자체를 저장하는 반면, `Integer`는 프리미티브 타입을 객체로 감싸는 래퍼 클래스입니다. `Integer`는 객체이므로 `null` 값을 가질 수 있으며, 메서드와 속성을 포함할 수 있습니다.

## Q. == 와 .equals()의 차이
- `==`는 **프리미티브 타입**에서는 값 비교를, **레퍼런스 타입**에서는 주소 비교를 합니다.
- `equals()`는 **객체의 값** 자체를 비교합니다.

---

# 변수와 데이터 타입

## 1. 변수란 무엇인가?
변수는 데이터를 저장하는 메모리 공간을 의미합니다. 자바에서는 변수를 사용하기 전에 반드시 선언해야 하며, 선언은 변수의 이름과 타입을 지정하는 것을 의미합니다.

### 1.1. 변수 선언 예시
```java
int age = 24; // 정수형 변수 age 선언 및 초기화
```
![](https://i.ibb.co/WH2MmqW/img.png)

## 2. 데이터 타입 (Data Type)
자바에서 변수의 데이터 타입은 크게 **프리미티브 타입**과 **참조 타입**으로 나뉩니다.

### 2.1. 프리미티브 타입 (Primitive Type)
프리미티브 타입은 값 자체를 저장하는 기본적인 데이터 타입으로, 자바에는 8가지의 프리미티브 타입이 있습니다:

![](https://i.ibb.co/fvHw7xn/img.png)

#### 2.1.1. 기본 값
프리미티브 타입의 기본 값은 다음과 같습니다:
- 정수형 타입: `0`
- 실수형 타입: `0.0`
- 문자형 타입: `\u0000` (null 문자)
- 논리형 타입: `false`

### char과 한글 입력

자바에서 `char`는 **UTF-16** 형식으로 인코딩된 **유니코드 문자**를 저장하는 데 사용됩니다. 유니코드에서 한글 문자는 2바이트로 표현되기 때문에, 자바의 `char` 타입은 한글을 저장할 수 있습니다.

#### 예시:
```java
public class CharArrayExample {
    public static void main(String[] args) {
        // 한글 문자를 유니코드로 표현
        char hanChar = '가';  // 유니코드 \uAC00
        System.out.println(hanChar);  // 출력: 가

        // 한글 문자열을 char 배열로 저장
        char[] koreanChars = {'안', '녕', '하', '세', '요'};
        for (char ch : koreanChars) {
            System.out.print(ch);  // 출력: 안녕하세요
        }
    }
}
```

## 2.2. 참조 타입 (Reference Type)

참조 타입은 객체나 배열 등 데이터 구조의 **참조(주소)**를 저장하는 타입을 말합니다. 참조 타입의 변수는 실제 데이터를 저장하는 대신 **메모리 주소**를 저장하며, 이를 통해 해당 객체나 배열에 접근합니다. 참조 타입의 대표적인 예로 `String` 클래스가 있습니다.

![참조 타입과 값 타입](https://i.ibb.co/cCj9x0x/Value-Types.png)

### 특징:
- **Primitive Type**을 제외한 모든 타입은 **Reference Type**입니다.
- 참조 타입은 자바에서 최상위 클래스인 `java.lang.Object` 클래스를 상속받는 모든 클래스를 포함합니다.
- **참조 타입**의 객체는 힙(Heap) 메모리에 저장되며, `new` 연산자로 인스턴스화합니다. 참조 변수는 스택(Stack) 메모리에 저장된 **참조값**(메모리 주소)을 가지고 있습니다.
- **Garbage Collector**는 힙에 생성된 객체를 추적하며, 더 이상 참조되지 않는 객체는 자동으로 메모리에서 해제됩니다.
- **Null 값**: 참조 타입의 변수는 기본적으로 `null` 값을 가집니다. `null`은 아무것도 참조하고 있지 않음을 의미하며, 이를 잘못 사용하면 **NullPointerException**이 발생할 수 있습니다.

### 참조 타입의 종류:
- **클래스 타입 (Class Type)**: 객체를 정의하고, 그 객체를 참조하는 타입.
- **인터페이스 타입 (Interface Type)**: 인터페이스를 참조하는 타입.
- **배열 타입 (Array Type)**: 배열을 참조하는 타입.
- **열거 타입 (Enum Type)**: 열거형 상수를 참조하는 타입.

### 참조 타입 예시:
```java
String name = "John";  // String 객체 참조
int[] numbers = {1, 2, 3};  // 배열 참조
```

### 주의점:
- 참조 타입의 변수는 선언 시 **null** 값을 가질 수 있으며, 변수가 `null`인 상태에서 객체나 배열에 접근하면 **NullPointerException**이 발생합니다.
- **힙 메모리**에 생성된 인스턴스는 JVM의 **스택 메모리**에 저장된 참조값을 통해 접근할 수 있습니다.

### 정리:
- **참조 타입**은 객체나 배열의 참조(메모리 주소)를 저장하는 타입입니다.
- **Primitive Type**이 아닌 모든 데이터 타입이 참조 타입에 속하며, `null` 값을 가질 수 있습니다.
- 참조 타입의 객체는 힙 메모리에 생성되며, 참조 변수를 통해 접근합니다.
- **NullPointerException**을 방지하기 위해 참조 변수를 사용할 때는 `null` 체크를 해야 합니다.

## 3. 타입의 불일치와 자동 형변환
프리미티브 타입 간의 형변환이 일어날 때, 좁은 범위의 타입에서 넓은 범위의 타입으로는 자동으로 변환이 일어나지만, 반대의 경우에는 명시적 형변환이 필요합니다.

### 3.1. 자동 형변환 (Implicit Casting)
다음과 같이, 작은 범위의 타입에서 큰 범위의 타입으로는 자동으로 형변환이 가능합니다:
```java
int i = 'A';       // OK. 문자 'A'의 유니코드 값 65가 저장됨.
long l = 123;      // OK. int에서 long으로 자동 형변환
double d = 3.14f;  // OK. float에서 double로 자동 형변환
```

### 3.2. 명시적 형변환 (Explicit Casting)
큰 범위의 타입을 작은 범위의 타입으로 변환할 때는 명시적 형변환이 필요합니다:
```java
double pi = 3.14;
int truncatedPi = (int) pi;  // 명시적 형변환 필요
```

### 3.3. 타입의 불일치 예시
```java
float f = 3.14;    // ERROR. float 타입 변수에 double 리터럴 저장 불가
int i = 0x123456789; // ERROR. int 타입의 범위를 넘는 값
```

## 4. 정수형 타입의 오버플로우

정수형 타입은 고정된 비트 수로 데이터를 저장하며, 1비트를 부호 비트로 사용하여 나머지 비트를 값을 표현하는 데 사용합니다. 만약 변수에 저장되는 값이 타입의 범위를 초과하면 상위 비트가 잘리고, 잘못된 값이 저장되는 **오버플로우**가 발생합니다. 예를 들어, `int` 타입은 4바이트(32비트)를 사용하며, 값의 범위는 약 -21억에서 +21억까지입니다.

오버플로우가 발생하면, 값이 부호 비트를 포함한 비트에 맞춰 잘리고, 나머지 상위 비트는 버려집니다. 따라서 원치 않는 값이 저장되거나 부호가 반전되는 등의 결과가 발생할 수 있습니다.

또한, JVM의 피연산자 스택은 피연산자를 4바이트 단위로 저장하므로, `byte`와 `short` 같은 4바이트보다 작은 자료형은 연산 시 4바이트로 변환되어 처리됩니다. 정수형 타입 중에서 더 큰 값이 필요하면 `long` 타입을 사용하는 것이 좋습니다. `byte`나 `short`는 메모리 공간을 절약할 필요가 있을 때 주로 사용됩니다.

### 예시 코드 (오버플로우)
```java
int maxInt = Integer.MAX_VALUE;  // 2147483647
int overflowedInt = maxInt + 1;  // 오버플로우 발생
System.out.println(overflowedInt); // 출력: -2147483648 (최소값으로 돌아감)
```

## 5. 실수형 타입의 정밀도와 언더플로우

실수형 타입은 값의 정밀도를 부호 비트, 지수 비트, 가수 비트로 나누어 표현합니다. 부호 비트는 1비트를 사용하고, 나머지 비트로 지수를 표현합니다. 정밀도는 가수 비트로 결정되며, 소수점 n번째 자리까지는 표현이 가능하지만, 그 이후 자리의 값은 저장되지 않아 오차가 발생합니다. 이 오차는 **정밀도 문제**로 이어집니다.

만약 실수형 타입으로 표현할 수 있는 값의 범위를 넘으면 **오버플로우**가 발생하며, 값이 `Infinity`로 저장됩니다. 반대로, 매우 작은 값을 저장하려 할 때 정밀도의 한계로 인해 0으로 처리되는 **언더플로우**가 발생할 수 있습니다.

실수형 타입의 경우 `float`(4바이트)보다 정밀한 `double`(8바이트)를 사용하는 것이 좋습니다. `float`보다 `double`은 더 넓은 범위와 정밀도를 제공하지만, 더 많은 메모리를 차지합니다.

### 예시 코드 (정밀도 문제)
```java
double a = 0.1 + 0.2;  // 정밀도 손실 발생
double b = 0.3;
System.out.println(a == b);  // 출력: false (정밀도 차이로 인해 값이 다름)
```

### 예시 코드 (언더플로우)
```java
float underflowedValue = 1e-40f;  // 매우 작은 값
System.out.println(underflowedValue);  // 출력: 0.0 (언더플로우 발생)
```

정리하자면:
- **오버플로우**는 정수형 타입에서 값이 타입의 범위를 넘어 상위 비트가 잘릴 때 발생합니다.
- **정밀도 문제**는 실수형 타입에서 표현할 수 없는 소수점 이하의 값들이 저장되지 않아 오차가 발생하는 문제입니다.
- **언더플로우**는 실수형 타입에서 매우 작은 값이 0으로 처리되는 현상입니다.

---

### [2. 오토박싱&언박싱,엡실론](./2.%20오토박싱&언박싱,엡실론.md)