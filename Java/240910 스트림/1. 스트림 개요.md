# Java 스트림(Stream) API

## 1. 스트림(Stream) 개요

### 1.1 정의
스트림(Stream)은 **데이터 소스**(배열, 컬렉션, 파일 등)를 추상화하여 데이터를 **일관된 방식으로 처리**하는 API입니다. 스트림을 사용하면 데이터를 필터링, 변형, 집계하는 작업을 반복문 없이 수행할 수 있으며, 함수형 프로그래밍 스타일을 통해 코드를 간결하고 효율적으로 작성할 수 있습니다.

Java 8에서 도입된 스트림 API는 데이터 처리의 가독성과 유지보수성을 높이며, 대용량 데이터를 처리할 때 성능을 향상시킬 수 있는 기능을 제공합니다. 스트림은 내부적으로 데이터 흐름을 제어하고, 필요한 연산을 최종 연산이 호출될 때까지 지연시킵니다. 이를 통해 스트림은 불필요한 연산을 방지하고, 성능을 최적화하는데 도움을 줍니다.

---

### 1.2 스트림의 주요 특징
1. **데이터 소스 읽기 전용**  
   스트림은 원본 데이터 소스를 변경하지 않고 **읽기만** 합니다. 이는 스트림이 데이터 소스를 처리하는 데 있어 순수한 변환을 제공하며, 원본 데이터를 안전하게 유지합니다. 스트림을 통해 처리한 결과는 새로운 데이터 구조(예: 리스트, 배열)에 담겨 반환될 수 있습니다.

2. **일회용**  
   스트림은 한 번 사용되면 닫히며, **재사용이 불가능**합니다. 즉, 스트림을 통해 데이터를 한 번 처리한 후에는 더 이상 해당 스트림을 사용할 수 없으며, 동일한 작업을 다시 수행하려면 새로운 스트림을 생성해야 합니다.

3. **지연 연산(Lazy Evaluation)**  
   스트림에서 제공하는 대부분의 연산은 **지연 연산**입니다. 이는 **중간 연산**이 즉시 실행되지 않고, **최종 연산**이 호출될 때 한꺼번에 처리된다는 의미입니다. 중간 연산을 여러 번 적용해도 성능에 큰 영향을 주지 않으며, 최종적으로 필요한 데이터만을 효율적으로 처리할 수 있습니다. 이를 통해 불필요한 연산을 피하고, 성능을 최적화할 수 있습니다.

4. **내부 반복 처리**  
   전통적인 반복문에서는 **외부 반복**을 사용해 데이터를 처리합니다. 즉, 개발자가 직접 데이터를 하나씩 처리하는 코드를 작성해야 합니다. 반면, 스트림은 **내부 반복**을 사용하여 데이터를 자동으로 처리합니다. 개발자는 반복문을 작성할 필요 없이 스트림의 함수형 메서드를 사용하여 데이터를 처리할 수 있습니다.

5. **병렬 처리 가능**  
   스트림은 **병렬 처리**를 지원합니다. `parallelStream()`을 사용하면 데이터는 여러 스레드에서 병렬로 처리되어 멀티코어 환경에서 성능이 크게 향상됩니다. 특히, 대용량 데이터를 처리할 때 병렬 처리를 통해 작업 시간을 단축할 수 있습니다.

6. **기본형 스트림**  
   스트림은 객체뿐만 아니라 **기본형 타입** 데이터를 처리할 수 있는 특화된 스트림을 제공합니다. 예를 들어, `IntStream`, `LongStream`, `DoubleStream`과 같은 기본형 스트림은 숫자형 데이터에 대해 최적화된 성능을 제공하며, 오토박싱 및 언박싱으로 인한 성능 저하를 줄일 수 있습니다.

---

## 2. 스트림의 특징 및 장점

### 2.1 내부 반복과 외부 반복

스트림에서 데이터를 처리하는 방식은 전통적인 반복문(For-loop)과는 달리 **내부 반복**을 사용합니다. **내부 반복**은 데이터를 자동으로 반복 처리하는 방식으로, 개발자가 명시적으로 반복문을 작성하지 않아도 스트림 메서드를 통해 데이터 처리가 이루어집니다.

#### 외부 반복 예시 (전통적 for-each)
```java
List<String> names = Arrays.asList("John", "Jane", "Doe");
for (String name : names) {
    System.out.println(name);
}
```

#### 내부 반복 예시 (Stream 사용)
```java
List<String> names = Arrays.asList("John", "Jane", "Doe");
names.stream().forEach(System.out::println);
```

**내부 반복**은 **병렬 처리**와 같은 최적화 기법을 쉽게 적용할 수 있으며, 데이터 처리의 흐름을 단순하고 명확하게 만듭니다. 반면, **외부 반복**은 개발자가 직접 데이터를 하나씩 처리해야 하며, 병렬 처리를 적용하려면 스레드 관리나 동기화를 직접 구현해야 합니다.

---

### 2.2 게으른 연산 (Lazy Evaluation)

스트림의 중요한 특징 중 하나는 **게으른 연산**입니다. **중간 연산**은 실제 데이터를 즉시 처리하지 않으며, **최종 연산**이 호출될 때 한꺼번에 실행됩니다. 이 방식은 불필요한 연산을 피하고 성능을 향상시키는 데 기여합니다.

예를 들어, `filter()`, `map()`과 같은 중간 연산은 최종 연산이 호출되기 전까지 대기하며, 스트림을 통한 데이터 처리에서 필요한 연산만 수행하게 됩니다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .filter(n -> {
           System.out.println("Filtering: " + n);
           return n > 2;
       })  // 중간 연산: 최종 연산이 호출될 때까지 실행되지 않음
       .map(n -> {
           System.out.println("Mapping: " + n);
           return n * 2;
       })  // 중간 연산
       .forEach(n -> System.out.println("Result: " + n));  // 최종 연산
```

위 예제에서 `filter()`와 `map()`은 중간 연산이며, `forEach()`가 호출될 때만 실제로 실행됩니다. 따라서 게으른 연산을 통해 성능 최적화를 이룰 수 있습니다.

---

### 2.3 파이프라인 (Pipeline)

스트림은 **파이프라인** 형태로 데이터를 처리합니다. 파이프라인은 **중간 연산**과 **최종 연산**을 연결한 데이터 처리의 흐름을 말합니다. 여러 중간 연산을 연속적으로 적용한 후, 최종 연산이 호출될 때 한꺼번에 실행되므로 성능을 효율적으로 관리할 수 있습니다.

#### 파이프라인 예시
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> result = numbers.stream()  // 스트림 생성
                              .filter(n -> n > 2)  // 중간 연산: 필터링
                              .map(n -> n * 2)     // 중간 연산: 매핑
                              .collect(Collectors.toList());  // 최종 연산: 수집
```

위 코드에서 `filter()`와 `map()`은 중간 연산으로서 데이터를 필터링하고 변환하는 역할을 합니다. `collect()`는 최종 연산으로 데이터를 리스트에 수집합니다. 이처럼 파이프라인 구조를 사용하면 데이터를 단계적으로 처리할 수 있으며, 코드의 가독성을 높일 수 있습니다.

---

### 2.4 병렬 처리

스트림은 **병렬 처리**를 통해 성능을 크게 향상시킬 수 있습니다. **병렬 스트림**(`parallelStream()`)을 사용하면 스트림은 내부적으로 데이터를 여러 스레드에서 병렬로 처리하게 되며, 특히 대용량 데이터를 처리할 때 유리합니다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
int sum = numbers.parallelStream()  // 병렬 스트림
                 .filter(n -> n % 2 == 0)
                 .mapToInt(Integer::intValue)
                 .sum();  // 30
```

병렬 스트림은 내부적으로 데이터를 분할하고, 각 분할된 데이터를 병렬로 처리한 후 결과를 다시 합칩니다. 이는 대용량 데이터 처리를 최적화하는 데 도움을 줍니다. 하지만, 순서가 중요한 작업에서는 병렬 스트림을 신중하게 사용해야 합니다.

---

## 외부 반복 & 내부 반복

다음 그림은 외부 반복과 내부 반복의 차이를 설명합니다. 스트림은 내부 반복을 사용해 데이터를 처리하며, 성능 최적화가 가능하다는 장점이 있습니다.

![외부 반복 & 내부 반복](https://i.ibb.co/x6R1RFf/2024-09-09-12-03-14.png)

- **외부 반복**은 개발자가 명시적으로 반복문을 사용하여 데이터를 처리합니다.
- **내부 반복**은 스트림이 자체적으로 데이터를 반복하며 처리합니다.

---

## 3. For vs Stream

### 3.1 유지 보수성 측면

스트림을 사용하면 코드의 가독성과 유지보수성이 크게 향상됩니다. 스트림은 함수형 프로그래밍

스타일을 지원하며, 이를 통해 복잡한 필터링, 변환, 집계 작업을 **메서드 체이닝** 방식으로 간결하게 작성할 수 있습니다.

#### Stream 예시 (가독성 높은 코드)
```java
public static List<EquipmentItemDto> filter(List<EquipmentItemDto> items) {
    return items.stream()
                .filter(item -> "Weapon".equals(item.getEquipmentPageName()) ||
                                "Cap".equals(item.getEquipmentPageName()))
                .collect(Collectors.toList());
}
```

#### For-loop 예시 (가독성 낮은 코드)
```java
public static List<EquipmentItemDto> filter(List<EquipmentItemDto> items) {
    List<EquipmentItemDto> filteredItems = new ArrayList<>();
    for (EquipmentItemDto item : items) {
        if ("Weapon".equals(item.getEquipmentPageName()) ||
            "Cap".equals(item.getEquipmentPageName())) {
            filteredItems.add(item);
        }
    }
    return filteredItems;
}
```

### 3.2 가독성 및 유지보수성

스트림은 데이터를 **파이프라인** 형태로 처리하여, 데이터 흐름을 명확하게 보여줍니다. 반면, For-loop은 복잡한 조건을 처리할 때 코드가 길어지며 가독성이 떨어집니다. 특히, 중첩된 반복문이나 조건문이 많아질 경우, 스트림을 사용하면 훨씬 더 명료한 코드를 작성할 수 있습니다.

---

## 4. 성능 비교

### 4.1 성능 최적화

스트림은 **게으른 연산**과 **내부 반복**을 통해 성능을 최적화할 수 있습니다. 불필요한 연산을 지연시키고, 병렬 처리를 통해 성능을 극대화할 수 있습니다. 특히 대용량 데이터 처리를 효율적으로 관리할 수 있습니다.

For-loop은 데이터를 순차적으로 처리하므로, 병렬 처리를 적용하려면 개발자가 직접 스레드를 관리하고 동기화를 구현해야 합니다. 이 때문에 병렬 처리가 필요한 상황에서는 스트림이 더 적합합니다.

---

## 5. 결론

Java 스트림 API는 코드를 간결하게 작성하고, 성능을 최적화할 수 있는 강력한 도구입니다. 스트림을 통해 데이터 처리의 가독성과 유지보수성을 향상시킬 수 있으며, 병렬 처리 기능을 통해 대용량 데이터를 효율적으로 처리할 수 있습니다.