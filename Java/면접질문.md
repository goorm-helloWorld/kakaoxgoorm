# Java Q&A

## Q. 자바 프로그램의 main() 메서드는 왜 public static void로 선언되나요?
* A: main() 메서드는 자바 프로그램의 진입점으로, 프로그램이 시작될 때 자바 가상 머신(JVM)에 의해 호출됩니다.
    * public: JVM이 외부에서 이 메서드를 호출할 수 있도록 접근을 허용합니다.
    * static: 객체를 생성하지 않고도 호출될 수 있도록 하기 위해 사용됩니다. 프로그램 시작 시 객체가 아직 생성되지 않았기 때문에 static으로 선언됩니다.
    * void: main() 메서드는 실행 후 아무런 값을 반환하지 않기 때문에 void로 선언됩니다.

## Q. Java의 프리미티브 타입과 레퍼런스 타입의 차이점
프리미티브 타입은 `int`, `float`, `boolean` 등과 같은 기본 데이터 타입으로, 값 자체를 저장합니다. 반면, 레퍼런스 타입은 객체의 주소를 저장하며, 예를 들어 `String`이나 배열 등이 이에 해당합니다.

## Q. int와 Integer의 차이점
`int`는 Java의 프리미티브 타입으로 값 자체를 저장하는 반면, `Integer`는 프리미티브 타입을 객체로 감싸는 래퍼 클래스입니다. `Integer`는 객체이므로 `null` 값을 가질 수 있으며, 메서드와 속성을 포함할 수 있습니다.

## Q. 오토박싱(Autoboxing)과 언박싱(Unboxing)이란?
- **오토박싱**: 프리미티브 타입을 자동으로 해당 래퍼 클래스 객체로 변환하는 과정입니다. 예를 들어, `int`가 `Integer`로 변환됩니다.
- **언박싱**: 래퍼 클래스 객체에서 프리미티브 타입의 값을 추출하는 과정입니다.

## Q. Call by Value와 Call by Reference의 차이점
Java는 **항상 Call by Value** 방식을 사용합니다. 기본 데이터 타입의 경우 값이 복사되어 전달되며, 레퍼런스 타입의 경우 객체의 주소값이 복사되어 전달됩니다. 하지만 레퍼런스 타입도 실제 객체가 전달되는 것은 아니며, 객체의 주소값만 전달됩니다.

## Q. 자바에서 final 키워드는 어디에 사용되며, 각각 어떤 의미를 가지나요?
* A: final 키워드는 변경 불가능성을 나타내며, 변수, 메서드, 클래스에서 사용할 수 있습니다.
    * 변수: final로 선언된 변수는 상수가 되며, 한 번 초기화된 후에는 값을 변경할 수 없습니다.
    * 메서드: final로 선언된 메서드는 오버라이딩이 불가능하며, 자식 클래스에서 재정의할 수 없습니다.
    * 클래스: final로 선언된 클래스는 상속이 불가능하며, 이 클래스를 부모 클래스로 하는 서브클래스를 만들 수 없습니다.

## Q. 배열과 컬렉션(Collection)의 차이점
- **배열**: 고정된 크기의 동일한 타입의 요소들을 저장합니다. 성능 면에서 효율적이지만, 크기가 고정되어 있어 유연성이 떨어집니다.
- **컬렉션**: 동적으로 크기가 변할 수 있는 데이터 구조로, 배열보다 유연하며 더 많은 기능을 제공합니다.

## Q. 배열의 크기를 동적으로 변경해야 할 경우에는 어떻게 해야 하나요?
A5: 배열의 크기는 생성 시에 고정되므로, 직접적으로 크기를 변경할 수 없습니다. 새 배열을 생성하고 기존 배열의 요소를 복사하는 방법을 사용해야 합니다. 이를 위해 `java.util.Arrays.copyOf` 메서드를 사용할 수 있습니다.
```java
int[] oldArray = {1, 2, 3};
int[] newArray = Arrays.copyOf(oldArray, 5); // 크기를 5로 확장
```

## Q. For문과 For-each문의 차이점
- **For문**: 초기화, 조건식, 증감식을 명시적으로 지정하여 반복을 제어할 수 있습니다.
- **For-each문**: 배열이나 컬렉션의 요소를 하나씩 순회하는 데 사용됩니다. 인덱스를 제어하거나 요소를 수정할 때는 For문이 더 적합합니다.

## Q. While문과 Do-while문의 차이점
- **While문**: 조건을 먼저 평가한 후 블록을 실행하며, 조건이 거짓이면 블록이 실행되지 않을 수 있습니다.
- **Do-while문**: 블록을 먼저 실행한 후 조건을 평가하여, 조건이 거짓이어도 최소 한 번은 실행됩니다.

## Q. Do-while문 사용 시기
반복 블록을 **최소 한 번은 실행해야 할 때** Do-while문을 사용합니다. 예를 들어, 사용자가 유효한 값을 입력할 때까지 입력을 반복 받는 경우에 유용합니다.

## Q. 배열의 최소값과 최대값을 찾는 방법
배열을 순회하면서 각 요소를 비교하여, 더 작은 값이나 더 큰 값을 발견할 때마다 해당 값을 갱신하는 방법을 사용할 수 있습니다. 또는 `Arrays.sort()`를 사용하여 배열을 정렬한 후, 첫 번째와 마지막 요소를 최소값과 최대값으로 얻을 수 있습니다.

## Q. == 와 .equals()의 차이
- `==`는 **프리미티브 타입**에서는 값 비교를, **레퍼런스 타입**에서는 주소 비교를 합니다.
- `equals()`는 **객체의 값** 자체를 비교합니다.

## Q. String, StringBuffer, StringBuilder의 차이
- **String**: 불변 객체입니다.
- **StringBuffer**: 가변 객체로, **스레드 안전**을 보장합니다.
- **StringBuilder**: 가변 객체로, **스레드 안전**을 보장하지 않습니다. 단일 스레드 환경에서 성능이 더 좋습니다.

## Q. Java에서 String Constant Pool이란 무엇이며, Java 7 이후에 어떻게 변경되었나요?
- **String Constant Pool**은 자주 사용하는 **String 객체를 재사용**하여 메모리 효율성을 높이는 메커니즘입니다. 동일한 문자열이 여러 번 사용될 때마다 새로운 객체를 생성하는 대신, 이미 생성된 객체를 재사용하여 메모리 사용을 줄입니다.

### Java 7 이전:
- **String Constant Pool**은 **PermGen 영역**에 존재했습니다.
- 이 영역은 JVM이 관리하는 메모리의 고정된 크기를 가지며, **가비지 컬렉션(GC)의 대상이 되지 않았습니다**. 따라서 참조가 없어도 String 객체가 메모리에서 해제되지 않는 경우가 많아 메모리 누수가 발생할 수 있었습니다.

### Java 7 이후:
- **String Constant Pool**이 **Heap 영역**으로 이동했습니다.
- 이제 참조를 잃은 String 객체는 **GC(가비지 컬렉션)**의 대상이 되어 메모리 관리가 더 효율적으로 이루어집니다.

### Java 8:
- Java 8에서는 **PermGen 영역이 완전히 삭제**되고, 그 자리는 **Metaspace**라는 새로운 메모리 영역으로 대체되었습니다. 이로 인해 PermGen과 관련된 메모리 부족 문제는 사라졌으며, String Constant Pool은 여전히 Heap 영역에 존재합니다.

### 결론:
- **String Constant Pool**은 메모리 절약을 위한 중요한 메커니즘으로, Java 7 이후로는 더 나은 메모리 관리가 가능해졌습니다. Java 8에서는 **PermGen**이 사라지고 **Metaspace**가 도입되어 더욱 개선된 메모리 관리 방식을 제공하게 되었습니다.

## Q. Thread-safe란?
스레드 안전(Thread-Safety)이란 **멀티스레드 프로그래밍**에서 여러 스레드가 동시에 접근해도 문제가 발생하지 않는 것을 의미합니다.

## Q. Java에서 Thread-safe 설계 방법
1. `java.util.concurrent` 패키지 사용
2. 인스턴스 변수를 두지 않음
3. **싱글톤 패턴** 적용
4. `synchronized` 블록 사용

## Q. 멀티 스레드 환경에서 StringBuilder를 안전하게 사용하려면 어떻게 해야 하나요?
A: 멀티 스레드 환경에서 StringBuilder를 안전하게 사용하려면 `synchronized` 키워드를 사용하여 동기화 블록을 추가하면 됩니다. 이를 통해 여러 스레드가 동시에 StringBuilder 객체에 접근하는 것을 방지하고, 데이터의 무결성을 유지할 수 있습니다.

## Q. 불변 객체와 가변 객체
- **불변 객체**: 생성된 이후에 내부 상태를 변경할 수 없는 객체입니다. (ex: `String`)
- **가변 객체**: 생성된 이후에 내부 상태를 변경할 수 있는 객체입니다.

## Q. 자바에서 OOP의 4대 핵심 개념
1. **캡슐화**: 데이터와 메서드를 하나로 묶어 외부에서 접근하지 못하도록 하는 것.
2. **상속**: 상위 클래스의 속성과 메서드를 하위 클래스에서 물려받아 사용하는 것.
3. **추상화**: 복잡한 세부 사항을 숨기고 중요한 것만 표현하는 것.
4. **다형성**: 하나의 메서드 호출이 상황에 따라 다르게 동작할 수 있는 것.

## Q. 캡슐화의 목적
캡슐화는 데이터를 보호하고 코드의 유지보수성을 높이는 것입니다. **getter**와 **setter** 메서드를 통해 데이터를 간접적으로 접근하도록 제한합니다.

## Q. 상속의 장점과 단점
- **장점**: 코드의 재사용성과 유지보수성이 높아집니다.
- **단점**: 과도한 상속은 코드의 복잡성을 증가시키고, 부모 클래스 변경 시 자식 클래스에 영향을 줄 수 있습니다.

## Q. 다중 상속을 지원하지 않는 이유
Java는 **다중 상속**을 허용하지 않습니다. 이는 다중 상속 시 발생할 수 있는 **다이아몬드 문제**를 방지하기 위함입니다. 다중 상속을 허용하면, 상속받은 클래스들 간에 동일한 메서드를 가질 경우 어느 메서드를 호출해야 하는지 모호해질 수 있습니다. 이를 해결하기 위해 Java는 **인터페이스**를 사용하여 다중 상속과 유사한 기능을 제공하고 있습니다.

## Q. Java에서 this와 super 키워드의 차이점은 무엇인가요?
* this: this는 현재 객체를 참조하는 키워드입니다. 주로 생성자나 메서드 내부에서 동일한 이름의 지역 변수와 인스턴스 변수를 구분하기 위해 사용됩니다. 예를 들어, 생성자에서 전달받은 매개변수와 인스턴스 변수를 구분할 때 this.변수명을 사용합니다.
* super: super는 부모 클래스를 참조하는 키워드입니다. 부모 클래스의 메서드나 생성자를 호출할 때 사용됩니다. 자식 클래스에서 부모 클래스의 메서드를 호출하거나, 부모 클래스의 생성자를 명시적으로 호출할 때 super를 사용합니다. 예를 들어, 부모 클래스의 생성자를 호출하려면 자식 클래스의 생성자에서 super(매개변수)를 사용합니다.

## Q. 다형성이란 무엇인가요?
다형성(Polymorphism)은 하나의 객체가 여러 형태를 가질 수 있는 능력을 의미합니다. 예를 들어, 부모 클래스의 메서드를 자식 클래스에서 오버라이딩하면, 동일한 메서드 호출이 객체의 타입에 따라 다른 동작을 수행할 수 있습니다. 다형성은 인터페이스나 상속을 통해 구현되며, 런타임 시에 결정되는 동적 바인딩(dynamic binding)으로 메서드가 호출됩니다.

## Q. 생성자(Constructor)란 무엇이며, 생성자의 주요 특징은 무엇인가요?
생성자는 객체가 생성될 때 자동으로 호출되는 메서드로, 주로 객체의 초기화를 위해 사용됩니다. 생성자의 주요 특징은 다음과 같습니다:
* 클래스 이름과 동일하다.
* 반환값이 없으며, 반환형을 명시하지 않는다.
* `new` 키워드를 통해 객체를 생성할 때 단 한 번 호출된다.
* 생성자는 오버로딩이 가능하여, 매개변수의 종류와 개수에 따라 여러 개의 생성자를 정의할 수 있다.
* 만약 클래스에 명시된 생성자가 하나도 없다면, 컴파일러가 자동으로 기본 생성자를 제공합니다.

## Q. 메서드 오버로딩(Overloading)과 오버라이딩(Overriding)의 차이
* **오버로딩(Overloading)**: 같은 이름의 메서드를 **매개변수 타입이나 개수를 달리하여** 여러 번 정의하는 것을 말합니다. 이는 **컴파일 시점**에 결정되며, 동일한 작업을 다양한 인수로 처리할 수 있게 합니다.
* **오버라이딩(Overriding)**: 상위 클래스의 메서드를 하위 클래스에서 **재정의**하는 것을 말합니다. 이는 **런타임 시점**에 결정되며, 부모 클래스의 메서드가 하위 클래스에서 다르게 동작하도록 할 수 있습니다. 다형성의 중요한 요소 중 하나입니다.

## Q. 메서드 오버라이딩의 규칙은 무엇인가요?
오버라이딩을 할 때는 다음과 같은 규칙을 따라야 합니다:
* 메서드의 이름과 매개변수 목록이 부모 클래스의 메서드와 동일해야 합니다.
* 오버라이딩된 메서드의 반환형은 부모 클래스의 메서드와 동일하거나 그 서브타입이어야 합니다.
* 오버라이딩된 메서드의 접근 지정자는 부모 클래스의 메서드와 같거나 더 넓은 범위여야 합니다. 예를 들어, 부모 클래스의 메서드가 `protected`라면, 자식 클래스에서는 이를 `protected`나 `public`으로 오버라이딩할 수 있습니다.
* 오버라이딩된 메서드에서 부모 클래스의 메서드를 호출할 때는 `super` 키워드를 사용합니다.

## Q. 클래스와 객체의 차이점은 무엇인가요?
- **클래스(Class)**: 클래스는 객체를 정의하는 틀 또는 설계도입니다. 클래스는 객체의 속성(멤버 변수)과 행동(메서드)을 정의하며, 객체가 가져야 할 공통된 특징을 기술합니다.
- **객체(Object)**: 객체는 클래스를 구체화한 실체로, 메모리에 로드된 인스턴스(instance)입니다. 클래스의 인스턴스인 객체는 물리적인 공간을 가지며, 클래스에서 정의한 속성과 행동을 실제로 가집니다. 예를 들어, '자동차'라는 클래스가 있다면, '내 차'라는 객체는 그 클래스의 인스턴스입니다.

## Q. 인스턴스 멤버와 정적 멤버의 차이점은 무엇인가요?
- **인스턴스 멤버**: 객체를 통해 접근하며, 각 객체마다 별도로 생성됩니다. 객체마다 고유한 값을 가지며, 객체가 소멸될 때 함께 소멸됩니다.
- **정적 멤버**: 클래스에 속하며, 객체를 생성하지 않고 클래스 이름으로 직접 접근할 수 있습니다. 프로그램 시작 시 생성되며, 프로그램 종료 시 소멸됩니다. 모든 객체가 해당 멤버를 공유합니다.

## Q. 접근 지정자 (public, private, protected)의 차이점
- **public**: 어디서든 접근 가능.
- **private**: 해당 클래스 내부에서만 접근 가능.
- **protected**: 같은 패키지 또는 상속받은 클래스에서 접근 가능.
- **default**: 접근 지정자를 명시하지 않으면 자동으로 적용되며, 같은 패키지 내에서만 접근 가능합니다.

## Q. 싱글톤 패턴(Singleton Pattern)이란 무엇이며, 어떻게 구현하나요?
싱글톤 패턴은 프로그램 내에서 특정 클래스의 인스턴스를 **하나만 생성**하도록 보장하는 디자인 패턴입니다. 주로 스레드 풀, 캐시, 설정 정보와 같은 자원 낭비를 방지해야 하는 경우에 사용됩니다.
* 구현 방법:
    1. 생성자를 `private`으로 선언하여 외부에서 인스턴스를 생성하지 못하게 합니다.
    2. 클래스 내부에 자신의 타입으로 정적 필드를 선언하고, 이 필드에서 자신의 인스턴스를 참조하게 합니다.
    3. `getInstance()` 메서드를 정적 메서드로 구현하여, 이를 통해 인스턴스에 접근할 수 있도록 합니다.

## Q. 추상 클래스와 인터페이스의 차이점
- **추상 클래스**: 일부 구현된 메서드를 가질 수 있으며, 단일 상속만 가능합니다.
- **인터페이스**: 모든 메서드는 기본적으로 추상 메서드이며, 다중 상속을 지원합니다.
### 사용 사례:
* **추상 클래스**: 예를 들어, 동물이라는 추상 클래스가 있다면, 이 클래스는 `소리내기()`라는 추상 메서드를 가질 수 있습니다. 고양이나 개 같은 하위 클래스는 각각 `소리내기()` 메서드를 구현하게 됩니다.
* **인터페이스**: 날 수 있는 인터페이스를 정의하고, 새, 비행기, 드론 같은 클래스가 이 인터페이스를 구현하여 `날기()` 메서드를 정의할 수 있습니다.

## Q. 추상 클래스와 인터페이스 중 어느 것을 사용해야 할지 어떻게 결정하나요?
추상 클래스는 공통된 필드와 메서드를 가지며, 일부 구현을 제공하고 싶을 때 사용합니다. 반면, 인터페이스는 클래스가 반드시 구현해야 하는 동작을 정의하고자 할 때 사용합니다. 만약 클래스가 여러 부모로부터 동작을 상속받아야 하거나, 다양한 구현체와 상호작용할 필요가 있다면, 인터페이스를 사용하는 것이 적합합니다. 반대로, 클래스 간 공통된 기능이 많고, 이를 재사용하고자 한다면 추상 클래스를 사용하는 것이 좋습니다.

## Q. 인터페이스에서 default 메서드와 static 메서드는 무엇인가요?
`default` 메서드는 Java 8부터 도입되었으며, 인터페이스에서도 메서드의 기본 구현을 제공할 수 있게 합니다. `static` 메서드는 인터페이스 자체에서 호출할 수 있는 메서드로, 객체를 생성하지 않고도 사용할 수 있습니다. 이를 통해 인터페이스는 보다 유연한 동작을 제공할 수 있습니다.

## Q. 다형성(Polymorphism)을 인터페이스와 함께 사용하는 이유는 무엇인가요?
다형성은 인터페이스를 통해 다양한 클래스의 객체를 동일한 방식으로 처리할 수 있게 해줍니다. 예를 들어, `RemoteControl` 인터페이스를 구현한 여러 클래스(SmartTV, Radio, Speaker 등)를 동일한 인터페이스 타입으로 다룰 수 있습니다. 이를 통해 코드의 유연성과 확장성을 높이고, 특정 구현에 종속되지 않는 코드를 작성할 수 있습니다.

## Q. `@FunctionalInterface` 어노테이션의 역할은 무엇인가요?
- `@FunctionalInterface` 어노테이션은 해당 인터페이스가 함수형 인터페이스임을 명시합니다.
- 하나의 추상 메서드만 가지는 인터페이스라는 것을 표시하며, 컴파일러가 이를 확인하도록 합니다.
- 두 개 이상의 추상 메서드가 선언되면 컴파일 오류가 발생합니다.

## Q. 람다식(Lambda Expression)이란?
람다식은 **익명 함수**를 나타내며, 주로 함수형 프로그래밍에서 사용됩니다. Java 8부터 도입되어 코드의 간결성과 가독성을 높입니다.
### 람다식 작성 예:
```java
MyFunction f = (x, y) -> x + y;
```

## Q. 자바에서 람다식을 사용하는 주요 이점은 무엇인가요?
1. **코드 간결화**: 람다식은 코드의 양을 줄이고 가독성을 높여줍니다.
2. **대용량 데이터 처리**: 필터링, 매핑 등의 작업을 쉽게 수행할 수 있어 대용량 데이터 처리에 유용합니다.
3. **성능 개선**: 람다식은 익명 클래스와 같은 객체를 생성하지만, 함수형 인터페이스를 사용하여 성능을 개선할 수 있습니다.

## Q. 람다식에서 중괄호 `{}`를 생략할 수 있는 경우는 어떤 경우인가요?
- 람다식의 실행문이 **단일 표현식**일 경우, 중괄호와 `return` 문을 생략할 수 있습니다.
- 예를 들어:
```java
(a, b) -> a + b;
```

## Q. 제너릭(Generic)이란?
제너릭은 클래스나 메서드를 선언할 때 **데이터 타입을 특정하지 않고**, 타입 파라미터를 통해 여러 타입을 다룰 수 있도록 하는 기법입니다. 이를 통해 코드 재사용성과 타입 안전성을 높일 수 있습니다.

## Q. 제너릭 타입을 사용하는 경우와 그렇지 않은 경우의 차이점은 무엇인가요?
1. **제너릭 미사용**:
    - 모든 데이터가 `Object` 타입으로 처리되므로, 데이터를 가져올 때마다 강제 타입 변환(casting)이 필요합니다.
    - 잘못된 타입이 들어가더라도 컴파일 시점에 오류가 발생하지 않으며, 런타임에 오류가 발생할 수 있습니다.
    - 코드 가독성과 안정성이 떨어집니다.

   **예시:**
   ```java
   List list = new ArrayList();
   list.add("hello");
   String str = (String) list.get(0);  // 강제 타입 변환 필요
   ```

2. **제너릭 사용**:
    - 타입 파라미터를 지정함으로써 강제 타입 변환이 불필요해지고, 코드의 가독성과 안정성이 높아집니다.
    - 컴파일 시점에 타입 검사를 통해 오류를 사전에 방지할 수 있습니다.

   **예시:**
   ```java
   List<String> list = new ArrayList<String>();
   list.add("hello");
   String str = list.get(0);  // 강제 타입 변환 불필요
   ```

### 결론:
- 제너릭을 사용하면 명확한 타입을 지정할 수 있어, 코드의 **안전성**과 **가독성**이 높아집니다.
- 제너릭을 사용하지 않으면 런타임에 타입 오류가 발생할 수 있으며, 코드 유지보수가 어려워질 수 있습니다.

## Q. 컬렉션 프레임워크(Collection Framework)
컬렉션 프레임워크는 **다수의 객체를 효율적으로 저장하고 관리하기 위한 표준화된 프로그래밍 방식**입니다. `List`, `Set`, `Map` 등의 인터페이스와 그 구현체들을 제공합니다.

## Q. 컬렉션 프레임워크에서 List, Set, Map의 차이점
- **List**: 순서가 있는 데이터의 집합으로, 중복된 요소를 허용합니다. (예: ArrayList, LinkedList)
- **Set**: 순서가 없는 데이터의 집합으로, 중복을 허용하지 않습니다. (예: HashSet, TreeSet)
- **Map**: 키와 값의 쌍으로 데이터를 저장하며, 키는 중복을 허용하지 않지만 값은 중복될 수 있습니다. (예: HashMap, TreeMap)

## Q. Queue와 Stack의 차이점은 무엇인가요?
- **Queue**:
    - **FIFO(First In First Out)** 구조로, 먼저 들어온 데이터가 먼저 나가는 방식입니다.
    - 순차적인 작업 처리에 적합합니다. 예를 들어, **프린터 작업 대기열**이나 **프로세스 관리**에 주로 사용됩니다.
    - 주요 메서드:
        - `add()`: 요소를 큐의 끝에 추가.
        - `poll()`: 큐에서 첫 번째 요소를 제거하고 반환.
        - `peek()`: 큐에서 첫 번째 요소를 반환하지만 제거하지 않음.

  **Queue 예시**:
  ```java
  Queue<String> queue = new LinkedList<>();
  queue.add("First");
  queue.add("Second");
  queue.add("Third");

  System.out.println(queue.poll());  // 출력: First
  ```

- **Stack**:
    - **LIFO(Last In First Out)** 구조로, 나중에 들어온 데이터가 먼저 나가는 방식입니다.
    - 후입선출 방식의 작업 처리에 적합합니다. 예를 들어, **함수 호출 스택**이나 **되돌리기 기능(Undo)** 등에 사용됩니다.
    - 주요 메서드:
        - `push()`: 스택에 요소 추가.
        - `pop()`: 스택에서 마지막에 추가된 요소를 제거하고 반환.
        - `peek()`: 스택에서 마지막에 추가된 요소를 반환하지만 제거하지 않음.

  **Stack 예시**:
  ```java
  Stack<String> stack = new Stack<>();
  stack.push("First");
  stack.push("Second");
  stack.push("Third");

  System.out.println(stack.pop());  // 출력: Third
  ```

### 차이점 요약:
- **Queue**는 **FIFO(First In First Out)** 구조로 먼저 들어온 데이터가 먼저 나가는 방식입니다.
- **Stack**은 **LIFO(Last In First Out)** 구조로 나중에 들어온 데이터가 먼저 나가는 방식입니다.
- Queue는 **순차적 작업 처리**에, Stack은 **후입선출 방식의 작업 처리**에 적합합니다.

## Q. Iterator는 무엇이며, 언제 사용하나요?
- **Iterator**는 컬렉션의 요소를 순차적으로 접근하는 데 사용되는 **인터페이스**입니다.
- 컬렉션의 **내부 구조**를 몰라도 요소를 하나씩 가져올 수 있으며, 특히 **순차적으로 탐색**하거나 **삭제**할 때 유용합니다.
- `Iterator`는 **컬렉션 프레임워크**에 속한 `List`, `Set`, `Map` 등의 데이터를 순차적으로 처리할 수 있는 방법을 제공합니다.

### 주요 메서드:
1. `hasNext()`: 다음 요소가 있는지 여부를 확인합니다. (boolean 반환)
2. `next()`: 다음 요소를 반환합니다.
3. `remove()`: 현재 요소를 컬렉션에서 삭제합니다. (삭제는 한 번만 가능합니다)

### 예시 코드:
```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class IteratorExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        // Iterator를 사용하여 요소 순회
        Iterator<String> iterator = list.iterator();
        
        while (iterator.hasNext()) {
            String element = iterator.next();
            System.out.println(element);
            
            // 요소 삭제
            if ("B".equals(element)) {
                iterator.remove();  // "B" 요소 삭제
            }
        }

        // 삭제 후 리스트 출력
        System.out.println("After removal: " + list);  // 출력: [A, C]
    }
}
```

### 결론:
- **Iterator**는 컬렉션을 순차적으로 탐색하면서 요소를 안전하게 제거할 수 있는 방법을 제공합니다.
- **내부 구조**에 의존하지 않고 컬렉션의 요소에 접근할 수 있으며, 반복문보다 더 **유연한 제어**가 가능합니다.

## Q. 스레드(Thread) 관련 메서드

1. **Thread.sleep()**:
    - 스레드를 지정된 시간 동안 일시 정지시킵니다.
   ```java
   try {
       Thread.sleep(2000);  // 2초 동안 대기
   } catch (InterruptedException e) {
       e.printStackTrace();
   }
   ```

2. **join()**:
    - 호출된 스레드가 종료될 때까지 현재 스레드를 일시 정지시킵니다.
   ```java
   try {
       thread.join();
   } catch (InterruptedException e) {
       e.printStackTrace();
   }
   ```

3. start()와 **run()**:
    - `start()`는 새로운 스레드를 생성하고 `run()` 메서드를 실행합니다.
    - `run()`을 직접 호출하면 새로운 스레드가 생성되지 않습니다.
   ```java
   thread.start();  // 새로운 스레드에서 run() 메서드 실행
   ```

4. **isAlive()**:
    - 스레드가 아직 실행 중인지 확인하는 데 사용됩니다.
   ```java
   if (thread.isAlive()) {
       System.out.println("Thread is still running.");
   }
   ```

5. **wait()**:
    - 현재 스레드는 `notify()` 또는 `notifyAll()` 메서드가 호출될 때까지 대기합니다.
    - **synchronized** 블록 안에서만 호출할 수 있습니다.

6. **notify()**:
    - `wait()` 메서드로 대기 중인 스레드 중 하나를 깨웁니다.

7. **notifyAll()**:
    - `wait()` 메서드로 대기 중인 모든 스레드를 깨웁니다.

8. **checkAccess()**:
    - 현재 스레드가 다른 스레드의 상태를 변경할 권한이 있는지 확인합니다. 권한이 없으면 `SecurityException`을 던집니다.

## Q. Thread 클래스의 `interrupted()` 메서드와 `isInterrupted()` 메서드의 차이점
1. **`interrupted()`**:
    - 현재 스레드가 인터럽트되었는지 확인하고, 확인 후 **인터럽트 상태를 초기화**합니다.
    - 즉, `true`를 반환한 후에는 상태가 `false`로 변경됩니다.

2. **`isInterrupted()`**:
    - 스레드의 인터럽트 상태를 확인하지만 **상태를 초기화하지는 않습니다**.

```java
// interrupted() 메서드 예시
if (Thread.interrupted()) {
    System.out.println("Thread was interrupted and reset");
}

// isInterrupted() 메서드 예시
if (thread.isInterrupted()) {
    System.out.println("Thread is interrupted");
}
```

## Q. `Runnable` 인터페이스와 `Thread` 클래스를 상속하는 것의 차이는 무엇인가요?
1. **Runnable 인터페이스**:
    - 다른 클래스를 상속받으면서도 멀티스레딩을 구현할 수 있게 합니다.
    - 자원 사용량이 적고, 익명 클래스나 람다식으로 간결하게 사용할 수 있습니다.
    - 코드 예시:
   ```java
   Runnable runnable = new MyRunnable();
   Thread thread = new Thread(runnable);
   thread.start();
   ```

2. **Thread 클래스 상속**:
    - 단일 상속만 가능하므로 **유연성이 떨어집니다**.
    - 다른 클래스를 상속받을 수 없는 제한이 있습니다.
    - 코드 예시:
   ```java
   class MyThread extends Thread {
       public void run() {
           // 스레드 로직
       }
   }

   Thread thread = new MyThread();
   thread.start();
   ```