# 3. 싱글스레드와 멀티스레드

### 3.1 **싱글스레드**
- **싱글스레드**는 하나의 스레드만으로 작업을 처리하는 방식입니다.
- **장점**: 스레드 간 전환 비용이 없기 때문에 전환 시간이 절약되어 단순한 작업에는 더 효율적일 수 있습니다.
- **단점**: CPU를 하나의 작업에만 사용할 수 있기 때문에, 다수의 작업을 동시에 처리할 수 없습니다.

### 3.2 **멀티스레드**
- **멀티스레드**는 여러 개의 스레드를 동시에 실행하여 자원을 더 효율적으로 사용할 수 있습니다.
- **장점**: 멀티코어 CPU에서 여러 작업을 병렬로 처리하여 성능을 높일 수 있습니다. 또한 사용자의 응답성을 향상시킬 수 있습니다.
- **단점**: 스레드 간 작업 전환에 시간이 소요되며, 동기화 문제를 처리하지 않으면 데이터 불일치와 같은 오류가 발생할 수 있습니다.

### 3.3 **싱글코어 vs 멀티코어**
- **싱글코어 환경**: 멀티스레드라도 하나의 코어에서 작업을 번갈아가며 수행하므로 두 작업이 겹치지 않고, 작업 전환 비용으로 인해 오히려 싱글스레드보다 성능이 낮을 수 있습니다.
- **멀티코어 환경**: 멀티스레드를 사용하면 여러 코어에서 작업을 병렬로 수행할 수 있으므로 성능이 향상됩니다. 특히, 서로 다른 자원을 사용하는 작업의 경우 멀티스레드가 훨씬 효율적입니다.

### 3.4 **스레드 전환과 스케줄링**
- 각 프로세스의 실행 시간과 순서는 **운영체제의 프로세스 스케줄러**에 의해 결정됩니다.
- 자바에서 스레드는 **JVM의 스레드 스케줄러**에 의해 실행되며, 할당된 시간에 따라 작업이 처리됩니다. 실행 중인 스레드가 없다면 프로그램은 종료됩니다.

---

# 3.5 멀티스레드 예제

### 1) **Thread 클래스를 상속받아 멀티스레드 구현**
다음 예시에서는 **Thread 클래스**를 상속받아 여러 스레드를 동시에 실행하는 방법을 보여줍니다.

#### 예시 코드:
```java
class MultiThread extends Thread {
    private int id;

    public MultiThread(int id) {
        this.id = id;
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Thread(" + id + "), i: " + i);
        }
    }
}

public class MultiThreadMain {
    public static void main(String[] args) {
        MultiThread t1 = new MultiThread(1);
        MultiThread t2 = new MultiThread(2);
        MultiThread t3 = new MultiThread(3);

        t1.start();
        t2.start();
        t3.start();
    }
}
```
- **MultiThread** 클래스는 **Thread 클래스**를 상속받아 스레드로 작업을 수행합니다.
- 여러 스레드를 동시에 실행하여 각각의 스레드가 병렬로 작업을 수행합니다.

---

# 3.6 스레드의 실행 제어

스레드를 제어하는 다양한 메서드를 통해 스레드의 실행 상태를 관리할 수 있습니다.

### 1) **주요 메서드**
- **sleep(long millis)**: 스레드를 지정된 시간 동안 일시 정지시킵니다.
- **join()**: 다른 스레드가 작업을 종료할 때까지 현재 스레드를 일시 정지시킵니다.
- **interrupt()**: 일시 정지된 스레드를 깨워 실행 대기 상태로 전환합니다.
- **stop()**: 스레드를 즉시 종료시킵니다 (권장되지 않음).
- **yield()**: 현재 스레드가 CPU 자원을 다른 스레드에게 양보합니다.

### 2) **suspend()와 resume()**
- **suspend()**: 스레드를 일시 정지시키고, **resume()**을 호출해야 다시 실행 대기 상태로 전환됩니다.
- **문제점**: 이 방식은 교착 상태(Deadlock)를 유발할 수 있으므로 사용이 권장되지 않습니다.

#### 예시:
```java
Thread t1 = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("Thread t1 is running - " + i);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});

Thread t2 = new Thread(() -> {
    try {
        t1.join();  // t1이 종료될 때까지 t2가 대기
        System.out.println("Thread t2 starts after t1 finishes");
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});

t1.start();
t2.start();
```
- **join()** 메서드를 통해 **t2** 스레드는 **t1** 스레드가 종료될 때까지 기다린 후 실행됩니다.

---

# 3.7 싱글스레드 vs 멀티스레드 비교

### 1) **싱글스레드의 특징**
- 하나의 스레드만 실행되므로 작업 간 전환이 필요 없습니다.
- 전환 시간이 없기 때문에 간단한 작업에서는 더 빠를 수 있습니다.
- 그러나 다중 작업을 처리하는 데 한계가 있습니다.

### 2) **멀티스레드의 특징**
- 여러 스레드를 동시에 실행하여 자원 활용도를 높일 수 있습니다.
- 다중 코어에서 병렬로 작업을 처리할 수 있어 성능이 향상됩니다.
- 하지만 스레드 간 자원 공유로 인한 **동기화 문제**와 **작업 전환 비용**이 발생할 수 있습니다.

---

# 3.8 결론

- **싱글스레드**는 간단한 작업이나 CPU 집중적인 작업에서는 더 효율적일 수 있습니다.
- **멀티스레드**는 자원을 효율적으로 사용하고, 특히 멀티코어 환경에서 병렬 처리를 통해 성능을 극대화할 수 있습니다.
- 스레드의 전환 비용과 동기화 문제를 고려하면서 멀티스레드를 사용해야 합니다.

