### TDD (Test Driven Development) - 테스트 주도 개발

TDD는 **코드 작성 전에 테스트를 먼저 작성**하고, 그 테스트를 통과할 수 있도록 코드를 개발하는 방식입니다. 이를 통해 **결함을 조기에 발견**할 수 있으며, 코드의 품질을 높이는 데 유리합니다.

#### **TDD의 세 가지 단계**
1. **Red**: 실패하는 테스트를 먼저 작성. 코드가 없기 때문에 테스트는 당연히 실패.
2. **Green**: 테스트를 통과하기 위한 **최소한의 코드** 작성.
3. **Refactor**: 테스트 통과 후 **코드를 개선** (중복 제거 등).
4. **기능 추가**: 이후 새로운 기능을 추가하고 반복.

#### **TDD의 장점**
- **코드 안정성**: 테스트를 통해 코드의 안정성을 높일 수 있음.
- **변경에 대한 안전망**: 기능 추가 또는 변경 시, 부작용(Side-Effect) 발생을 줄일 수 있음.
- **목적 명확**: 작성된 코드의 목적을 명확하게 표현하며, 불필요한 코드를 줄일 수 있음.

TDD는 **애자일 개발 방식**의 일부로, 테스트를 중심으로 개발 방향을 잡아 나가며 피드백을 통해 **코드 설계 방향을 일치**시킬 수 있습니다.

---

### JUnit이란?

JUnit은 자바 진영에서 널리 사용되는 **테스트 프레임워크**로, **단위 테스트**(Unit Test)를 위한 도구를 제공합니다.

#### **단위 테스트란?**
- 코드의 특정 모듈이 의도한 대로 동작하는지 **검증**하는 절차.
- 모든 함수와 메소드에 대해 **테스트 케이스**를 작성하여 동작을 확인.
- **어노테이션**을 통해 테스트를 쉽게 지원.
- **단정문(Assert)**으로 테스트 결과가 기대한 대로 나오는지 검증.
- Spring Boot 2.2 버전부터 **JUnit 5**를 사용하며, JUnit 5는 **Jupiter**, **Platform**, **Vintage** 모듈로 구성됨.

#### **JUnit 모듈 설명**

1. **JUnit Jupiter**
    - **JUnit 5**의 **TestEngine API** 구현체.
    - 개발자가 작성한 테스트 코드를 발견하고 실행하는 역할을 담당.

2. **JUnit Platform**
    - 테스트를 실행하기 위한 **뼈대 역할**.
    - **TestEngine 인터페이스**를 통해 테스트를 발견하고 실행하며 결과를 보고함.
    - 다양한 **IDE와 연동**을 지원 (콘솔 출력 등).

3. **JUnit Vintage**
    - JUnit 3, 4로 작성된 테스트 코드를 실행하기 위한 **TestEngine API** 구현체.

#### **JUnit LifeCycle Annotation**

JUnit 5는 아래와 같은 **테스트 라이프 사이클**을 가집니다:

- **@Test**: 테스트용 메소드로 정의.
- **@BeforeEach**: 각 테스트 메소드 실행 전에 수행.
- **@AfterEach**: 각 테스트 메소드 실행 후 수행.
- **@BeforeAll**: 테스트 시작 전에 한 번만 실행 (static으로 선언해야 함).
- **@AfterAll**: 모든 테스트가 끝난 후 한 번만 실행 (static으로 선언해야 함).

JUnit은 이러한 기능을 통해 자바 애플리케이션의 **자동화된 테스트**를 효과적으로 지원합니다.

---

### JUnit 주요 어노테이션 정리

1. **@SpringBootTest**
    - **통합 테스트**에 사용되는 어노테이션.
    - `@SpringBootApplication`을 찾아서 하위의 모든 **Bean**을 스캔하고 로드함.
    - **Test용 Application Context**를 만들어 **Bean**을 추가하거나 **MockBean**으로 교체 가능.

2. **@ExtendWith**
    - JUnit 4의 `@RunWith`를 대체하는 어노테이션.
    - 테스트 실행 시 **메인으로 실행할 클래스**를 지정할 수 있음.
    - `@SpringBootTest`에는 기본적으로 포함되어 있음.

3. **@WebMvcTest(Class.class)**
    - **지정된 클래스**만 실제로 로드하여 테스트를 진행.
    - 매개변수를 지정하지 않으면 **Controller**, **RestController**, **RestControllerAdvice** 등의 **컨트롤러 관련 Bean**만 로드.
    - 전체 스프링 Bean을 로드하는 대신, **컨트롤러 관련 코드**만 테스트할 때 사용.

4. **@Mockbean**
    - **MockMVC 객체**를 주입받아 **Controller의 API**를 테스트.
    - `perform()` 메소드를 활용해 **컨트롤러 동작**을 테스트 (e.g. `andExpect()`, `andDo()`, `andReturn()` 사용).

5. **@MockBean**
    - 테스트할 클래스에 주입되는 **가짜 객체(Mock)**를 생성하는 어노테이션.
    - **단위 테스트**에서 실제 서비스 객체를 사용하지 않고, **가짜 객체**를 사용해 테스트 가능.
    - `given()` 메소드를 통해 **가짜 객체의 동작**을 정의.

6. **@AutoConfigureMockMvc**
    - **MockMVC 설정**을 자동으로 로드하고 주입해주는 어노테이션.
    - **MockMVC**는 **REST API 테스트**에 사용됨.

7. **@Import**
    - 필요한 클래스들을 **Configuration**으로 만들어 사용할 때 사용.
    - **Configuration** 클래스도 의존성 설정 가능하며, **Import**된 클래스는 주입되어 사용됨.

이 어노테이션들은 각각 **테스트 환경 구성**과 **테스트 대상 코드**를 쉽게 구분하고 제어할 수 있게 도와줍니다.

---

### 통합 테스트 (Integration Test)

- **통합 테스트**는 여러 기능을 조합하여 전체 비즈니스 로직이 올바르게 동작하는지 확인하는 테스트입니다.
- 스프링 부트에서는 **@SpringBootTest** 어노테이션을 사용하여 통합 테스트를 진행합니다.
    - **@SpringBootTest**는 **@SpringBootApplication**을 찾아 모든 **Bean**을 로드하여 테스트 환경을 구성합니다.
    - 대규모 프로젝트에서는 테스트 실행 시 **모든 Bean**을 로드해야 하므로 테스트가 무거워질 수 있습니다.

### 단위 테스트 (Unit Test)

- **단위 테스트**는 프로젝트 내의 **각각의 기능**을 독립적으로 테스트하는 것입니다.
- 스프링 부트에서는 **'spring-boot-starter-test'** 디펜던시만으로 **단위 테스트**에 필요한 모든 의존성을 가질 수 있습니다.
    - 단위 테스트는 빠르고 간결하게 개별 기능을 확인할 수 있습니다.

### F.I.R.S.T 원칙 (테스트 코드의 좋은 원칙)

1. **Fast**: 테스트 코드는 빠르게 실행되어야 합니다.
2. **Independent**: 각 테스트는 서로 독립적이어야 하며, 다른 테스트에 영향을 주지 않아야 합니다.
3. **Repeatable**: 테스트는 반복 실행 시 항상 동일한 결과를 반환해야 합니다.
4. **Self-Validating**: 테스트는 스스로 결과를 검증해야 하며, 별도의 추가 확인 없이 테스트 결과가 명확해야 합니다.
5. **Timely**: 단위 테스트는 비즈니스 코드가 완성되기 전에 작성되어야 합니다.

이 원칙들은 **테스트 주도 개발(TDD)**의 중요한 개념으로, 코드 작성 전에 테스트가 먼저 작성되어야 한다는 것을 강조합니다.