# **스프링에서의 트랜잭션 사용**

트랜잭션은 데이터베이스 작업이 **ACID** 속성을 보장하는지 확인하는 매커니즘입니다. **ACID**는 다음과 같은 네 가지 속성을 포함합니다:

- **Atomicity(원자성)**: 트랜잭션 내의 모든 작업이 완벽하게 수행되거나 전혀 수행되지 않음을 보장.
- **Consistency(일관성)**: 트랜잭션이 성공하면 일관된 데이터 상태를 보장.
- **Isolation(고립성)**: 각 트랜잭션은 서로 영향을 주지 않음.
- **Durability(지속성)**: 트랜잭션이 성공적으로 완료되면 그 결과가 영구적으로 보장됨.

### 1. **스프링에서의 트랜잭션 관리 방법**

1. **선언적 관리**
    - **@Transactional** 어노테이션을 사용해 트랜잭션을 선언적으로 관리합니다.
    - 코드에서 트랜잭션을 직접 다루지 않아도 되고, 트랜잭션 시작과 종료(커밋 또는 롤백)가 자동으로 처리됩니다.
    - 클래스에 적용하면 그 클래스의 모든 메서드에 트랜잭션이 적용되고, 메서드에 적용하면 특정 메서드에만 트랜잭션이 적용됩니다.

2. **프로그래밍적 관리**
    - **TransactionTemplate** 또는 **PlatformTransactionManager**를 사용해 트랜잭션을 수동으로 관리합니다.
    - 세밀한 트랜잭션 제어가 필요할 때 사용되며, 트랜잭션의 시작과 종료를 수동으로 처리해야 합니다.

### 2. **트랜잭션 전파(Propagation)**

트랜잭션 전파는 하나의 트랜잭션이 다른 메서드를 호출할 때 트랜잭션이 어떻게 처리될지를 정의합니다. 스프링은 여러 전파 옵션을 제공합니다:

- **REQUIRED(기본값)**: 현재 트랜잭션이 있으면 그 안에서 실행하고, 없으면 새 트랜잭션을 시작합니다.
- **REQUIRED_NEW**: 항상 새 트랜잭션을 시작합니다.
- **MANDATORY**: 현재 트랜잭션이 없으면 예외가 발생합니다.
- **SUPPORTS**: 현재 트랜잭션이 있으면 그 안에서 실행하고, 없으면 트랜잭션 없이 실행합니다.
- **NOT_SUPPORTED**: 트랜잭션 없이 실행합니다.
- **NEVER**: 트랜잭션이 있으면 예외가 발생합니다.

### 3. **트랜잭션 격리 수준(Isolation Level)**

여러 트랜잭션이 동시에 실행될 때 데이터의 일관성을 유지하는 방법을 정의합니다:

- **DEFAULT**: 데이터베이스의 기본 격리 수준을 따릅니다.
- **READ_UNCOMMITTED**: 가장 낮은 격리 수준. 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있습니다.
- **READ_COMMITTED**: 커밋된 데이터만 읽습니다.
- **REPEATABLE_READ**: 트랜잭션이 시작되면 같은 트랜잭션 내에서 읽은 데이터는 변하지 않음을 보장합니다.
- **SERIALIZABLE**: 가장 높은 격리 수준으로, 모든 트랜잭션을 순차적으로 처리하여 데이터 일관성을 보장합니다.

### 4. **트랜잭션 롤백 규칙**

- 기본적으로 **RuntimeException** 또는 **Error**가 발생하면 트랜잭션이 롤백됩니다.
- **Checked Exception**은 롤백되지 않지만, **rollbackFor** 속성을 사용해 롤백할 수 있습니다.

### 5. **트랜잭션 시간 제한 및 읽기 전용 설정**

- **시간 제한**: 트랜잭션을 실행할 수 있는 최대 시간을 지정할 수 있습니다. 시간이 초과되면 트랜잭션은 강제로 롤백됩니다.
- **읽기 전용 트랜잭션**: 트랜잭션 내에서 데이터 수정 작업을 방지하는 설정입니다.

---

### **MyBatis와 JPA 비교**

|  | **JPA** | **MyBatis** |
| --- | --- | --- |
| **ORM** | JPA는 객체와 데이터베이스 테이블을 자동으로 매핑해주는 **ORM** 기술입니다. | MyBatis는 SQL 문과 자바 객체를 수동으로 매핑해주는 SQL 매퍼 프레임워크입니다. |
| **SQL** | SQL을 자동으로 생성해주기 때문에 개발자가 직접 작성할 필요가 없습니다. | SQL을 직접 작성해야 하지만, 복잡한 쿼리 제어가 가능합니다. |
| **장점** | - 객체지향적인 방식으로 DB 작업을 할 수 있습니다. <br> - DB 종류가 변경돼도 SQL을 다시 작성할 필요가 없습니다. | - 복잡한 쿼리나 특정 데이터베이스에 최적화된 쿼리를 작성할 때 유리합니다. |
| **단점** | - 러닝 커브가 높고, 복잡한 쿼리를 다루기 어려울 수 있습니다. | - CRUD 작업에서 수작업이 반복될 수 있습니다. <br> - 특정 데이터베이스에 종속된 SQL을 많이 사용할 수 있습니다. |

---

### **MyBatis**

**MyBatis**는 SQL Mapper 프레임워크로, 개발자가 직접 작성한 SQL 문을 통해 데이터베이스 작업을 수행합니다. **JDBC** 작업을 단순화하며, XML을 통해 자바 객체와 SQL 쿼리를 매핑할 수 있습니다.

---

### **JPA와 Hibernate**

1. **JPA(Java Persistence API)**는 자바에서 ORM을 위한 표준 인터페이스입니다. JPA는 데이터베이스와 객체를 매핑하며, 이를 통해 SQL 문 없이 데이터베이스 작업을 할 수 있습니다.

2. **Hibernate**는 JPA의 가장 널리 사용되는 구현체로, JPA가 제공하는 기능 외에도 여러 가지 확장 기능을 지원합니다.

---

이처럼 스프링에서 트랜잭션 관리와 데이터베이스 연동은 **JPA**, **MyBatis**, 또는 **Hibernate**와 같은 다양한 기술을 통해 이루어집니다. **트랜잭션**은 데이터의 일관성과 신뢰성을 보장하며, 선언적 또는 프로그래밍 방식으로 구현할 수 있습니다.